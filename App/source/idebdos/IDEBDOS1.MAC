        .Z80
;
DEBUG   equ     0
;
TITLE   'IDE/SD RAW I/O driver - BDOS extension for CP/M'
;
; IDEBDOS v1 functions:
;
BASE	equ	176	; 240	; 129
BBEGIN  equ     0+BASE	; begin diapazon
BHOME   equ     0+BASE	; set LBA=0    (inp:nothing;          out:nothing)
BSETDSK equ     1+BASE	; set drive    (inp:E=drive;          out:HL=0->err)
BSETTRK equ     2+BASE	; set cylinder (inp:DE=cylinder;      out:nothing)
BSETSEC equ     3+BASE	; set sector   (inp:E=sector, D=head; out:nothing)
BSETDMA equ     4+BASE	; set buffer   (inp:DE=address;       out:nothing)
BREAD   equ     5+BASE	; read sector  (inp:nothing;          out:A=0->ok)
BWRITE  equ     6+BASE	; write sector (inp:nothing;          out:A=0->ok)
BIOCTL  equ     7+BASE	; get params   (inp:DE=mode;          out:A=0->ok)
BGETDT  equ	8+BASE	; get date     (inp:nothing;          out:HL=MSDOS date)
BGETTM  equ	9+BASE	; get time     (inp:nothing;          out:HL=MSDOS time)
;
; IDEBDOS v2 functions:
;
BSETDT  equ	10+BASE	; set date      (inp:DE=MSDOS date;  out:nothing)
BSETTM  equ	11+BASE	; set time      (inp:DE=MSDOS time;  out:nothing)
BMREAD  equ     12+BASE	; read D sectors(inp:D=count,E=dest_bank; out:A=0->ok)
BMWRITE equ     13+BASE	; write sectors (inp:D=count,E=dest_bank; out:A=0->ok)
BEND    equ     13+BASE	; end diapazon.
;
FBUF    equ     0F310h	; temporary buffer for routines processing 512b-blocks
FBUFSZ	equ	20h	; size temporary routines (20h)
FBUFCOD equ	FBUF
doFBUFcode equ	FBUFCOD
BDOS    equ     5
XARGV	equ	80h	; CP/M buffer of programm input commands string (params)
PF9     equ     0F9h
;
; AltairDos v3.x (Orion Z80 CP/M) specific
;
YBDOS   equ     0F301h	; 24-bit BDOS vector, reg.B=caller segment (BestDos)
int50   equ     0F331h	; BestDos 50 Hz interrupt vector
BLDIR	equ	0F201h	; send BC bytes beginning from A+HL to A'+HL'
BJMP    equ     0F204h  ; go to address (bank:address) addressed by A+HL
BCALL	equ	0F207H  ; call to address (bank:address) addressed by A+HL
MARKER  equ     0EFFFh  ; every memory bank has unique marker (bank N) at 0EFFFh
DRVBANK equ     0FFH	; „+LL+¶¶T+„T + ¶LT¶¶ T++T
DRVADDR equ     0FFFFh	; ++ ¶LT¶¶ ¶¶-L¶-T¶„¶ +-T+L
;
; Advanced CPM (Orion CP/M) specific
;
APAGE	equ	1	; memory page where ACPM resides
ABDOS   equ     0F2D0h	; BDOS interbank vector (ACPM)
YSEG	equ	10h	; caller segmet (for pass bank_number=1 in ACPM)
;
; IDE specific
;
ide_8255     equ 058h		;PPA base address
;ide_8255_lsb equ ide_8255+2	;pC - lower 8 bits
;ide_8255_msb equ ide_8255+1	;pB - upper 8 bits
;ide_8255_ctl equ ide_8255+0	;pA - control lines
;ide_8255_cfg equ ide_8255+3	;     8255 configuration register
;rd_ide_8255  equ 10001011b	;ide_8255_ctl out, ide_8255_lsb/msb input
;wr_ide_8255  equ 10000000b	;all three ports output
;
;ide_a0_line  equ 01h       ;direct from 8255 to ide interface
;ide_a1_line  equ 02h       ;direct from 8255 to ide interface
;ide_a2_line  equ 04h       ;direct from 8255 to ide interface
;ide_cs0_line equ 08h       ;inverter between 8255 and ide interface
;ide_cs1_line equ 10h       ;inverter between 8255 and ide interface
;ide_wr_line  equ 20h       ;inverter between 8255 and ide interface
;ide_rd_line  equ 40h       ;inverter between 8255 and ide interface
;ide_rst_line equ 80h       ;inverter between 8255 and ide interface
;
;ide_data     equ   ide_cs0_line
;ide_err      equ   ide_cs0_line + ide_a0_line
;ide_sec_cnt  equ   ide_cs0_line + ide_a1_line
;ide_sector   equ   ide_cs0_line + ide_a1_line + ide_a0_line
;ide_cyl_lsb  equ   ide_cs0_line + ide_a2_line
;ide_cyl_msb  equ   ide_cs0_line + ide_a2_line + ide_a0_line
;ide_head     equ   ide_cs0_line + ide_a2_line + ide_a1_line
;ide_command  equ   ide_cs0_line + ide_a2_line + ide_a1_line + ide_a0_line
;ide_status   equ   ide_cs0_line + ide_a2_line + ide_a1_line + ide_a0_line
;ide_control  equ   ide_cs1_line + ide_a2_line + ide_a1_line
;ide_astatus  equ   ide_cs1_line + ide_a2_line + ide_a1_line + ide_a0_line
;
;Address port of IDE Rtc
portIdeDataH	equ	57h
portIdeDataL	equ	58h
portIdeErr		equ	59h
portIdeSeccen	equ	5ah
portIdeSector	equ	5bh
portIdeCylLB	equ	5ch
portIdeCylHb	equ	5dh
portIdeHead		equ	5eh
portIdeStatus	equ	5fh	;read
portIdeCom		equ	5fh	;write
portIdeAstat	equ	56h	;Alt. status registr
;
;IDE Command Constants.  These should never change.
;
ide_cmd_recal    equ 10h
ide_cmd_read     equ 20h
ide_cmd_write    equ 30h
ide_cmd_init     equ 91h
ide_cmd_id       equ 0ECh
ide_cmd_spindown equ 0E0h
ide_cmd_spinup   equ 0E1h
;
; head and device register: bit 4 : 0=master,1=slave
;
ide_dev_master   equ 0
ide_dev_slave    equ 00010000b
;
CMD0   equ 040h +  0 ; resets the card
CMD9   equ 040h +  9 ; read CSD
CMD10  equ 040h + 10 ; read CID
CMD16  equ 040h + 16 ; set R/W block
CMD17  equ 040h + 17 ; read block
CMD24  equ 040h + 24 ; write block
CMD55  equ 040h + 55 ; next command is ACMDxx
CMD58  equ 040h + 58 ; READ_OCR
ACMD41 equ 040h + 41 ; send host capacity support, init card
;
SD_ADDR	equ	0F762h
SD_ADR2	equ	0F763h
SD_PWR	equ	08h	; POWER OFF/ON=0/1 (positive logic)
SD_CS	equ 	04h 	; NPN inverter, positive logic.
SD_CLK	equ 	02h
SD_DOUT	equ 	01h
SD_DIN	equ	80h 
FTimeout equ	20000
;
rdy_repeat   equ 400h   ; repeat count in  ide_wait_ready
;
;------------------------------------------------------------------
;
	jp	BEGIN
HEADER: db      13,10,'IDEBDOS V2.1. (c) 2015 Serge.$'
HDRPORT:db	'  ?=HELP  Port: $'
MERROR: db	'Out of XTPA memory or allready installed',13,10,'$'
NoIDE:	db	13,10,'No devices found. Driver not installed',13,10,'$'
BADSYS: db      13,10,'Incorrect CP/M version. (NOT CP/M 2.2.)',13,10,'$'
NOBESTSYS:db	'CP/M treated upon Orion Advanced CP/M (ACPM 1.x)',13,10,'$'
BESTSYS:db	'Detected Altair DOS 3.x or higher.',13,10,'$'
NOZ80:  DB      13,10,'No Z80 CPU.',13,10,'$'
;
IF DEBUG
msg_dbg1:db     13,10,13,10,"BEFORE DRIVER INSTALL",13,10,'$'   
msg_dbg2:db     13,10,13,10,"AFTER DRIVER INSTALL",13,10,'$'    
ENDIF
;
msg_msx: db	13,10,"SD-card: MSX v1 scheme",13,10,"$"
msg_n8:	 db	13,10,"SD-card: N8VEM scheme",13,10,"$"
msg_ad:	 db	",  Addr: $"
msg_wp:  db	13,10,"Wrong parameter: $"
msg_n01: db	13,10,"Wrong parameter: not specified device 0: or 1:$"
msg_1:   db     13,10,13,10,"Begin devices autodetect (less then 20sec per device)... be patient!"
crlf:    db	13,10,'$'
msg_mdl: db     13,10,"Model: ",'$'
msg_sn:  db     13,10,"S/N:   ",'$'
msg_rev: db     "      Rev:   ",'$'
msg_cy:  db     13,10,"Cyls:",'$'
msg_hd:  db     ",  Heads:",'$'
msg_sc:  db     ",  Sects:",'$'
msg_tot: db	",  Total:$"
msg_mb:	 db	"Mb$"
msg_m:   db     13,10,"Master (drive  0:) : ",'$'
msg_s:   db     13,10,13,10,"Slave  (drive  1:) : ",'$'
msg_rdy: db     "Drive not ready",'$'
msg_stat:db     13,10,"Status reg = ",'$'
msg_err: db     13,10,"Error, code = ",'$'
msg_chs: db     13,10,"Position:  CHS=",'$'
msg_l:   db     "LBA=",'$'
msg_ly:	 db	",  Access: LBA",'$'
msg_ln:	 db	",  Access: CHS",'$'
msg_ro:  db	", RO$"
msg_hlp: db	13,10,13,10,"Usage: IDEBDOS [<device>:<param_list> [<device>:<param_list>]]"
	 db	13,10,"       [Port:<hex_addr>] [Addr:<hex_bank>,<hex_addr>] [NOINT] [SD] [HELP] [?]",13,10
	 db	13,10," where  Addr:<bank,addr> - driver resides at <bank,addr>(hex). (ACPM only)"
	 db	13,10,"        Port:<addr>    - treat IDE/SD on port <addr>(hex).  Default F600/F762."
	 db	13,10,"        HELP, ? (/?)  - show this help and exit"
	 db	13,10,"        NOINT        - pause interrupts during disk I/O"
	 db	13,10,"        SD           - access SD-card instead of IDE, so IDE params ignored"
	 db	13,10,"        <drive>      - 0=IDE-master, 1=IDE-slave, or 0=SD-card (in SD mode)"
	 db	13,10,"        <param_list> - comma separated any list of IDE parameters:"
	 db	13,10,"                       RO    - use device in read-only mode (both IDE, SD)"
	 db	13,10,"                       RW    - use device in read-write mode (default)"
	 db	13,10,"                       CHS   - use CHS access mode instead of identified"
	 db	13,10,"                       LBA   - use LBA access mode instead of identified"
	 db	13,10,"                       RECAL - recalibrate device after reset (very old drives)"
	 db	13,10,"                     C=<num> - use <num>(dec) cyllinders instead of identified"
	 db	13,10,"                     H=<num> - use <num>(decimal) heads instead of identified"
	 db	13,10,"                     S=<num> - use <num>(decimal) sectors instead of identified"
	 db	13,10,"Example:"
	 db	13,10," idebdos 0:ro,chs,c=1800,h=16,s=128,recal 1:rw,lba addr:0,8000 port:F600 noint",13,10,"$"
;
intflag: db     0       ; 1 indicates what second interrupt begun
intbank: ds     1
intaddr: ds     2
;
pp_bank:db	0		; ACPM default - driver at bank N  0
pp_addr:dw	9000h		; ACPM default - driver at address 9000h
pp_port:dw	0
;
s_addr:	db	"ADDR:",0
s_port:	db	"PORT:",0
s_ro:	db	"RO",0
s_rw:	db	"RW",0
s_chs:	db	"CHS",0
s_lba:	db	"LBA",0
s_recal:db	"RECAL",0
s_c:	db	"C=",0
s_h:	db	"H=",0
s_s:	db	"S=",0
s_0:	db	"0:",0
s_1:	db	"1:",0
s_ques1:db	"?",0
s_ques2:db	"/?",0
s_ques3:db	"-?",0
s_help: db	"HELP",0
s_sd:	db	"SD",0
s_noint:db	"NOINT",0
;
par_tbl:dw	s_addr,  p_addr
	dw	s_port,  p_port
	dw	s_ro,    p_ro
	dw	s_rw,    p_rw
	dw	s_chs,   p_chs
	dw	s_lba,   p_lba
	dw	s_recal, p_recal
	dw	s_c,     p_c
	dw	s_h,     p_h
	dw	s_s,     p_s
	dw	s_0,     p_0
	dw	s_1,     p_1
	dw	s_ques1, p_help
	dw	s_ques2, p_help
	dw	s_ques3, p_help
	dw	s_help,  p_help
	dw	s_sd,	 p_sd
	dw	s_noint, p_noint
	dw	0
;
;port_tbl:
;	dw	@@P1+1,  @@P2+1,  @@P3+1,  @@P4+1,  @@P5+1,  @@P6+1,  @@P7+1,  @@P8+1
;	dw	@@P9+1,  @@P10+1, @@P11+1, @@P12+1, @@P13+1, @@P14+1, @@P15+1, @@P16+1
;	dw	@@P17+1, @@P18+1, @@P19+1, @@P20+1, @@P21+1, @@P22+1, 0
;
portsd_tbl:
	dw	@@SD1+1,  @@SD2+1,  @@SD3+1,  @@SD4+1,  @@SD5+1,  @@SD6+1,  @@SD7+1
	dw	@@SD8+1,  @@SD9+1,  @@SD10+1, @@SD11+1, 0
;
bank_tbl:
	dw	@@B1+1,  @@B2+1,  @@B3+1,  wrblkA+1, rdblkA+1,  wrblkAA+1, rdblkAA+1,  0
;
BEGIN:  XOR     A
        ld      (lastdsk), a
        DEC     A
        LD      DE,NOZ80
        JP      PE,MSG          ; CPU Z80 ?
        ld      c,12
        call    BDOS
	ld	de, BADSYS
	ld	a, h
	or	a
	jp	nz, MSG
	ld	a, l 
	cp	22h
	jp	nz, MSG
        exx
	ld	a,h
        cp      0ABh            ; is OS - BEST DOS ?
	push	af		; extended OS version
        ld      de,HEADER
        call    MSG             ; L„LT-
        LD      HL,(1)
        LD      DE,6
        ADD     HL,DE
	ld	(CONI2+1), hl	; BIOS - CONIN
	inc	hl
	inc	hl
	inc	hl
        LD      (CON0),HL       ; BIOS - CONOUT
	ld	(CONO2+1), hl
	call	get_params	; process command line parameters
	ld	de, HDRPORT
	call	MSG
	ld	de, ide_8255	; IDE: base address
;	ld	bc, port_tbl	; IDE: hlat table address
	ld	a, (drv_sign)
	and	1
	jr	z, beg		; if IDE mode
	ld	de, SD_ADDR	; SD: base address
	ld	bc, portsd_tbl	; SD: hlat table address
beg:	ld	hl, (pp_port)	
	ld	a, h
	or	l
	jr	nz, beg0	; if controller address allready sets by command line
	ld	h, d
	ld	l, e
	ld 	(pp_port), hl
beg0:	ld	a, h	
	call	phex		; display PPA port address
	ld	a, l
	call	phex		; hl=destination port address
;
; Correct IDE port addresses for PPA (IDE). 
;  Input: hl=(destination base port address)
;	  de=(source=compiled base port address)
;         bc=hlat table address
;
;	xor	a		; CY=0
;	sbc	hl, de		; hl=(destination port address)-(source/compiled base port address)=offset
;	ex	de, hl		; de=offset
;sport0:	ld	a, (bc)
;	ld	l, a		; hl=address of address to correct
;	inc	bc
;	ld	a, (bc)
;	ld	h ,a
;	or	l
;	jr	z, sport1	; end of port_tbl table 
;	ld	a, (hl)		; low part of value to correct
;	add	a, e
;	ld	(hl), a
;	inc	hl
;	ld	a, (hl)		; high part of value to correct
;	adc	a, d
;	inc	bc
;	jr	sport0
sport1:
;
	pop	af
	push	af
	jr	z, beg1
	ld	de, msg_ad
	call	MSG
	ld	a, (pp_bank)
	call	PRHEX0	
        ld      a, ','
        call    cout
	ld	hl, (pp_addr)
	ld	a, h
	call	phex
	ld	a, l
	call	phex
beg1:	ld      de, msg_1
        call    msg
	pop	af
        ld      de,NOBESTSYS
        jp      nz, nobest      ; jp if ACPM
	ld	de, BESTSYS
	call	MSG
best:				; if Altair Dos
	ei
	call    int20		; calculate 10ms timing value
	ld	a, (MARKER)
	ld	(CONO1+1), a
	ld	(CONI1+1), a
        ld	hl, XGETPARAMS_B
	ld	(XIOCTLTAB), HL
	call	initialize_ide
	ld	de, NoIDE
	jp	z, MSG		; no IDE devices - exit without driver installation
;
        ld      de,DRVNAME      ; driver descriptor
        ld      c,106           ; delete driver if allready installed
        call    BDOS
        ld      a,(YBDOS)
        ld      hl,(YBDOS+1)
        ld      (XBDOS1+1),a
        ld      (XBDOS2+1),hl   ; store YBDOS old vector value
;
        ld      de,DRVSTR	; driver descriptor
        ld      c,105
        call    BDOS            ; install driver
        ld      de,MERROR
        INC     A
        RET     NZ
MSG:    push	ix
	push	iy
	push	hl
	push	bc
	ld      c,9
        call    BDOS
	pop	bc
	pop	hl
	pop	iy
	pop	ix
	ret
;
nobest:	call	MSG		; if ACPM
	ld	hl, (BDOS+1)	; check for allready installed
	inc	hl
	ld 	a, (hl)
	inc	hl
	ld	h, (hl)
	ld 	l, a		; hl=internal BDOS entry address
	ld	(ZCONT1+1), hl  ; for continue BDOS calls chain
	ld      de, ABDOS
	or	a		; carry flag := 0
	sbc	hl, de
	ld	de, MERROR
	jp	z, MSG		; hl=YBDOS -> allready installed
	call	initialize_ide
	ld	de, NoIDE
	jp	z, MSG		; no IDE devices - exit without driver installation
;
	ld 	hl, XGETDTA
	ld	(@X9), hl
	ld 	hl, XGETTMA
	ld	(@X10), hl	; no time/date in ACPM
	ld 	hl, XSETDTA
	ld	(@X11), hl
	ld 	hl, XSETTMA
	ld	(@X12), hl	
;
	ld	a, (pp_bank)
	ld	c, a
	call	set_bank	; correct bank number where driver resides (ACPM)
	ld	a, 0C9h		; RET opcode
	ld	(RET1), a
	ld	(RET2), a	; do not perform BestDos initialization
	ld	a, 21h		; ld hl, m   opcode
	ld	(ALINK0),a
	xor	a		; NOP opcode
	ld	(ALINK1), a	; do not address shift in ACPM
	ld	(ALINK2), a	; do not address shift in ACPM
	ld	hl, @@S1+1
	ld	(HLATTAB), hl
	ld	hl, @@S2+1
	ld	(HLATTAB+2), hl
	ld	hl, (pp_addr)
	call	INSTA		; correct driver absolute addresses to new values
	ld	hl, ldir0
	ld      de, ABDOS
	ld	bc, ldir00-ldir0
	ldir			; service subroutine for driver move
	ld	hl, DBEG
	ld	de, (pp_addr)
	ld	bc, DEND-DBEG
	call    ABDOS           ; move driver code to destination bank,address

	ld	hl, ZCALL
	ld      de, ABDOS
	ld	bc, ZCALL0-ZCALL
	ldir			; prepare BCALL area
;
	ld      de, ABDOS
	ld	hl, (BDOS+1)	
	inc	hl
	ld	(ZSDSK1-ZCALL+ABDOS+1), hl
	ld	(hl), e		; reassign BDOS internal vector
	inc	hl
	ld	(hl), d

	ld	bc, 25		; catch bios seldsk to prevent from bdos autorestore
	ld	hl, (1)
	add	hl, bc
	ld	bc, ZSELDSK-ZCALL+ABDOS	; new BIOS seldsk vector value
	ld	e, (hl)
	ld	(hl), c
	inc	hl
	ld	d, (hl)		; de = old BIOS seldsk vector value
	ld	(hl), b		; BIOS seldsk vector value := ASELDSK
	ld	(ZSDSK2-ZCALL+ABDOS+1), de
IF DEBUG
	ld	de, msg_dbg2
	call	MSG
ENDIF
	jp	0		; for ACPM do BIOS warm start at exit
;
ldir0:  ld	a,(hl)
	ex	af,af'
@@B1:	ld	a, 0
	out	(PF9),a
	ex	af,af'
	ld	(de),a	
	ld	a, APAGE
	out	(PF9),a
	inc	hl
	inc	de
	dec	bc
	ld	a,b
	or	c
	ret	z
	jr	ldir0
ldir00:
;
ZCALL:	ld      a,c
	cp      BBEGIN          ; check for diapazon BBEGIN..BEND
ZCONT1: jp      c, 0
	ld      (ZRET0-ZCALL+ABDOS+1), sp
@@B2:	ld	a, 0
	out	(PF9),a
@@S1:	ld	sp, ACPMSTACK-2	; stack in bank where driver resides (ACPM)
@@S2:	call	XXBDOS		; both corected by INSTA call 
	ex	af, af'
	ld	a, APAGE
	out	(PF9),a
	ex	af, af'
ZRET0:	ld	sp, 0
	ret
ZSELDSK:ld	hl, ABDOS
ZSDSK1:	ld	(0), hl
ZSDSK2:	jp	0
ZCALL0:
;
; Correct destination bank number where drive resides. Input: c - bank number
;
set_bank:
	ld	hl, bank_tbl
sbank0:	ld	e, (hl)
	inc	hl
	ld	a, (hl)
	ld	d, a
	inc	hl
	or	e		
	ret	z		; end of bank_tbl table - return
	ld	a,c
	ld	(de), a
	jr	sbank0
;
; Grap substring, ended by eow=[':', '=', ',', ' ', '\0'] from input string
; passed by pointer (HL) to buffer at (DE). HL moved to eow char
;
xstrgrab:
	ld	a, (hl)
	inc	hl
	cp	' '
	jr	z, xstrgrab		
	ld	(de), a
	inc	de
	call	testeow
	ret	z		; string ended
	jr	xstrgrab
;
; Compare 2 strings, ended by [':', '=', ',', ' ', '\0'], passed by pointers
; in DE (param), HL(pattern).  Return result in flags: Z - if equal, NZ - if not 
; HL, DE moved to nonequal position (if NZ) or to end of strings (if Z)
;
xstrcmp:
	ld	a,(de)
	call	UPCASE
	cp	(hl)
	jr	nz, xsc1	; strings may be both ended, but by different chars
	call	testeow
	ret	z		; strings equal and both ended
	inc	de
	inc	hl
	jr	xstrcmp	
xsc1:	call	testeow
	ret	nz		; string at (de) not ended and not equal to (HL)
	ld	a,(hl)
;
; tests if char (in acc) is end_of_word marker: return flag Z if eow, NZ if not
;
testeow:cp	':'
	ret	z
	cp	'='
	ret	z
	cp	','
	ret	z
	or	a
	ret	z
	cp	021h
	jr	c, sporl	; if space or less
	cp	' '		; NZ
	ret
sporl:	cp	a		; Z
	ret
;
gpnext:	push	hl
	ld	de, buffer
	push	de
	call	xstrgrab
	ld	a, '$'
	ld	(de), a
	ld	de, msg_wp
	call	MSG
	pop	de
	call	MSG
	pop	hl
gpn1:	ld	a, (hl)
	call	testeow
	jr	z, gp0		; end of analyzing substring (one word)
	inc	hl
	jr	gpn1
;
gpnp:	inc	bc		; set (bc) to next patern word
	inc	bc		; skip subroutines addr
	ex	de, hl		; hl=begin of input word (parameter)
	jr	gp2
;
; param str at 080h:
;   "0:ro,chs,c=1800,h=16,s=128,recal  1:rw,lba  addr:0,A000  port:F500"
;
get_params:
	ld	hl, XARGV
	ld	a, (hl)
	or	a
	ret	z		; no input params
	inc	hl
	ld	iy, 0FFFFh	; Device Param Block handle not initialized
gp0:	ld	bc, par_tbl	; patterns table start address
gp1:	ld	a, (hl)
	or	a
	ret	z		; end of analyzed string (input params)
	call	testeow
	jr	nz, gp2
	inc	hl
	jr	gp1		; skip all spaces and eow`s (hl := next word)
gp2:	ld	a, (bc)		; bc=addr of next pattern word pair {word^,addr}
	ld	e, a
	inc	bc
	ld	a, (bc)
	ld	d, a		; de=pointer to pattern string
	or	e
	jr	z, gpnext	; if end of patterns table, goto next input word
	inc	bc
	push	hl		; (hl)=begin of input word
	ex	de,hl		; (hl)=pattern
	call	xstrcmp
	ex	de,hl		; (hl)=at end of compare, (de)=at end of pattern
	pop	de
	jr	nz, gpnp	; if str(HL)<>str(DE) then next BC->(DE), hl:=beg of word
	ld	de, gp0		
	push	de		; return address for p_* subroutines
	ld	a,(bc)
	ld	e, a
	inc	bc
	ld	a, (bc)
	ld	d, a		; de=pointer to subroutine p_*
	inc	bc
	push	de
	ret			; jp (DE)
;
UPCASE: AND     7FH
	CP      61H
	RET     C
	CP      7BH
	RET     NC
	SUB     20H
	RET
;
shex0:	inc	hl
seekhex:ld	a,(hl)
	or	a
	ret	z
	call	upcase
	cp	'0'
	jr	c, shex0	; less then '0'
	cp	'9'+1
	jr	c, shexit	; if '0'..'9'
	cp	'A'
	jr	c, shex0	; less then 'A'
	cp	'G'
	jr	nc, shex0	; greater then 'F'
shexit: or	a		; NZ
	ret
;
sdec0:	inc	hl
seekdec:ld	a,(hl)
	or	a
	ret	z
	call	upcase
	cp	'0'
	jr	c, sdec0	; less then '0'
	cp	'9'+1
	jr	nc, sdec0	; greater then '9'
	or	a		; NZ
	ret
;
gethex:	ld	de, 0
gh1:	ld	a, (hl)
	or	a
	ret	z
	inc	hl
	call	upcase
	cp	'0'
	ret	c	; less then '0'
	cp	040h
	jr	c, gh2	; if '0'..'9'
	cp	'A'
	ret	c	; less then 'A'
	cp	'G'
	ret	nc	; greater then 'F'
	sub	'A'-10
	jr	gh3	; 10..15
gh2:	sub	'0'	; 0..9
gh3:	ex	de, hl
	call	hl16
	ex	de, hl
	add	a, e
	ld	e, a
	jr	gh1	
;
getdec:	ld	de, 0
gd1:	ld	a, (hl)
	or	a
	ret	z
	inc	hl
	call	upcase
	cp	'0'
	ret	c	; less then '0'
	cp	040h
	ret	nc	; greater then '9'
	sub	'0'	; 0..9
	ex	de, hl
	call	hl10
	ex	de, hl
	add	a, e
	ld	e, a
	jr	gd1
;
checkiy:push	iy
	pop	de
	inc	de
	ld	a,e
	or	d
	ret	nz
	ld	de, msg_n01
	pop	af		; pop return address - break caller
	jp	MSG		; not specified "0:" or "1:"	
;
p_addr:	call	seekhex
	ret	z
	call	gethex
	ld	a, e
	ld	(pp_bank),a	; bank
paddr0: ld	a, (hl)
	or	a
	ret	z
	call	testeow
	jr	nz, paddr1
	inc	hl
	jr	paddr0
paddr1:	call	gethex
	ld	(pp_addr), de	; addr
	ret
;
p_port: call	seekhex
	ret	z
	call	gethex
	ld	(pp_port), de	; port
	ret
;
p_rw:	call	checkiy
	xor	a
	ld	(iy+21), a	; a=0  -> read_write
	ret
;
p_ro:	call	checkiy
	ld	(iy+21), a	; a<>0  -> read_only
	ret
;
p_chs:	call	checkiy
	xor	a
	ld	(iy+1), a	; a=0 -> nonLBA mode
	ret
;
p_lba:	call	checkiy
	ld	a,2
	ld	(iy+1), a	; a=0 -> nonLBA mode
	ret
;
p_recal:call	checkiy
	ld	a, 1
	ld	(iy+22), a
	ret
;
p_c:	call	checkiy
	call	seekdec
	ret	z
	call	getdec
	ld	(iy+9), e
	ld	(iy+10), d
	ret
;
p_h:	call	checkiy
	call	seekdec
	ret	z
	call	getdec
	ld	(iy+11), e
	ret
;
p_s:	call	checkiy
	call	seekdec
	ret	z
	call	getdec
	ld	(iy+12), e
	ld	(iy+13), d
	ret
;
p_0:	ld	iy, MasterInfo
	inc	hl
	ret
;
p_1:	ld	iy, SlaveInfo
	inc	hl
	RET
;
p_help: ld	de, msg_hlp
	call	MSG
	jp	0
;
p_sd:	ld	a, 1		; 1=SD-card instead of IDE
	ld	(drv_sign), a
	ret
;		
p_noint:xor	a		; 1=SD-card instead of IDE
	ld	(no_int+1), a
	ret
;		
;==================================================
;HL=HL*100
HL100:   CALL HL10        ;HL=HL*100
HL10:    ADD  HL,HL       ;HL=HL*10
         PUSH DE
         LD   D,H
         LD   E,L
         ADD  HL,HL
         ADD  HL,HL
         ADD  HL,DE
         POP  DE
         RET
;
;==================================================
;HL=HL*256
HL256:   CALL HL16        ;HL=HL*256
HL16:    ADD  HL,HL       ;HL=HL*16
         ADD  HL,HL
         ADD  HL,HL
         ADD  HL,HL
         RET
;
; ---------------- SD card ------------------
;
sd_tab1:
	jp	sd_wiggle_n8vem
	jp	sd_fini_n8vem
	jp	sd_put_n8vem
	jp	sd_get_n8vem
sd_tab2:
	jp	sd_wiggle_msx
	jp	sd_fini_msx
	jp	sd_put_msx
	jp	sd_get_msx
sd_tab3:
;
; read byte N8VEM
;
	push	bc		
	ld	b, 8
L22:	ld	a, (de)
	rla			; SD_DIN is RTC.7
	rl	(hl)
	ld	a, SD_PWR + SD_CS + SD_DOUT + SD_CLK
	ld	(de), a
	and	NOT SD_CLK
	ld	(de), a
	djnz	L22
	pop	bc
sd_tab4:
;
; write byte N8VEM
;
	push	bc
	ld	c, (hl)
	ld 	b, 8
L33:	ld 	a, 6
	rl 	c
	rla
	ld	(de), a
	or 	SD_CLK
	ld	(de), a
	djnz	L33
	xor	SD_CLK
	ld	(de), a
	pop	bc
sd_tab5:
;
; SD probe, disappears on mount
;
sd_init:xor	a
@@SD1:	ld	(SD_ADDR), a	; power off
	ld	b, a
	ld	c, a
delay0:	dec	bc		
	ld	a, b
	or	c
	jr	nz, delay0	; delay (6+4+4+12=26)*65536 tstates (~0.4s at 5MHz)
delay1:	ld	a, SD_PWR
@@SD2:	ld	(SD_ADDR), a	; power on
	djnz	delay1		; delay (7+12+13=32)*256 tstates (~50ms at 5MHz)
sdinit:	call	sd_wiggle	; power on, wiggle
	call	sd_select	; ignore busy condition
	call	sd_init_1
	jp	sd_done		
;
; z return if ok
; idle, ready, size, set block size
;
sd_init_1:			; 02f0
	ld	a, CMD0		; GO_IDLE_STATE
	call	sd_command_no_arg
	cp	001h
	ret	nz		; not "idle"

sd_notready:
	ld	a, CMD55	; APP_CMD
	call	sd_command_no_arg
	and	11111110b	; ~001h
	ret	nz		; not "idle" nor "ok"

	ld	a, ACMD41	; SD_SEND_OP_COND. arg 0x40000000 is HCS
	call	sd_command_no_arg
	cp	001h
	jr	z, sd_notready	; wait, while idle
	or	a
	ret	nz		; not ok

	ld	a, CMD9		; SEND_CSD
	call	sd_command_no_arg
	ret	nz		; not ok

	call	sd_wait_token	; packet start or FF if timed out
	cp	0FEh
	ret	nz		;  or error

	ld	hl, buffer	; XXX
	ld	b, 16+2         ; including crc16
L7:
	call	sd_get
	ld	(hl), a		; temporary read CSD to /dev/null :)
	inc	hl
	djnz	L7		; do 16+2 bytes
;
; CSD in buffer. calculate something
;
;=================================================
;
	ld	a, CMD10	; SEND_CID
	call	sd_command_no_arg
	ret	nz		; not ok

	call	sd_wait_token	; packet start or FF if timed out
	cp	0FEh
	ret	nz		;  or error

	ld	hl, buffer+16	; XXX
	ld	b, 16+2         ; including crc16
L77:
	call	sd_get
	ld	(hl), a		; temporary read CSD to /dev/null :)
	inc	hl
	djnz	L77		; do 16+2 bytes
;
; CID in buffer+16. calculate something
;
;=================================================
;
	ld	a, CMD58	; READ_OCR
	call	sd_command_no_arg
	ret	nz		; not ok
	call	sd_get
	push	af
	call	sd_get
	call	sd_get
	call	sd_get
	pop	af
	and	040h    	; NZ if SDHC
	ret
;
;-------------------- SD-card cold init ------------------------------
;
cold_sd:call	sd_init
	ld	de, msg_msx
	jr	z, coldsd2	; if card present & MSX scheme
	ld	hl, sd_tab1	; 
	ld	de, sd_tab0
	ld	bc, sd_tab2-sd_tab1
	ldir			; else switch to N8VEM scheme
	call	sd_init
	jr	nz, coldsd1	; if both schemes fail
	ld	hl, sd_tab3
	ld	de, rdsd
	ld	bc, sd_tab4-sd_tab3
	ldir			; switch read cycle to N8VEM scheme, hl:=sd_tab4
	ld	de, wrsd
	ld	c,  sd_tab5-sd_tab4
	ldir			; switch write cycle to N8VEM scheme
	ld	hl, (pp_port)	
	ld	(@SD0+1), hl
	ld	(@SD1+1), hl	
	ld	de, msg_n8
	jr	coldsd2
coldsd1:ld	hl, sd_tab2	; 
	ld	de, sd_tab0
	ld	bc, sd_tab3-sd_tab2
	ldir			; both tests fail -> back to MSX scheme (default scheme)
sderr:	xor	a		; a=0 , Z -> no devices found
	ret
coldsd2:call	msg
;
; display CID data
;
	ld	de, msg_mdl	; 13,10,"Model: ",'$'   buffer+16+3...buffer+16+7  ACSII
	call	msg
	ld	b, 5
	ld	hl, buffer+16+3
CID0:	ld	a, (hl)
	cp	20h
	call	nc, cout
	inc	hl
	djnz	CID0

;	ld	de, msg_sn	; 13,10,"S/N: ",'$'   buffer+16+9...buffer+16+12  DWORD
;	call	msg

	ld 	ix, buffer			

;	ld	a, (ix+16+12)
;	ld	b, (ix+16+11)
;	ld	c, (ix+16+10)
;	call	wrdata
	ld	de, msg_rev	; "  Rev: ",'$'   buffer+16+8    BCD-BYTE
	call	msg
	ld	a, (ix+16+8)
	PUSH    AF
        RRCA
        RRCA
        RRCA
        RRCA
        CALL    PRHEX0
	ld	a, '.'
	call	cout
        POP     AF
	call	PRHEX0
;
; display CSD data
;
	ld 	l, (ix+8)
	ld	h, (ix+7)
	ld	a, (ix+6)
	and	3
	add	hl, hl
	rla
	add	hl, hl
	rla
	ld	l, h
	ld	h, a
	inc	hl		; hl = c_size + 1
;
; c_size_mult = ix[10] + (ix[9] & 0x03) * 256
; c_size_mult >>= 7    ( 3 bits )
;
	ld	a, (ix+10)
	rla
	ld	a, (ix+9)
	rla
	and	7			
	ld	b, a		; b = c_size_mult
;
; read_bl_len = ix[5] & 0x0F  ( 4 bits )
;
	ld	a, (ix+5)
	and	0Fh		; a = read_bl_len
	add	a, b
	sub	7		; a = c_size_mult + read_bl_len - 7
	ld	de, 0
	jr	c, sderr	; ERROR - negative exponent
	jr	z, skipsl	; exponent=0 -> no shift
;
; dehl <<= a,  A is 1...31
;
	ld	b, a
sl_dehl:add	hl, hl
	rl	e
	rl	d
	djnz	sl_dehl
skipsl:
	ld	(MaxLba0+0), hl   ; XXX overflows at 4GB
	ld	(MaxLba0+2), de
;	ld	(MaxLba1+0), hl   
;	ld	(MaxLba1+2), de

	ld	ix, MasterInfo 
	call	showtot
	ld	de, crlf
	call	MSG
	xor	a
	inc	a		; a=1 , NZ
	ld	(Ready0), a
;	ld	(Ready1), a
	ret 
;
;-------------
;	
showtot:ld	de, msg_tot
	call	MSG		; total
	ld	a,(ix+17)
	ld	b,(ix+16)
	ld	c,(ix+15)
	rrca
	rr	b
	rr	c
	rrca
	rr	b
	rr	c
	rrca
	rr	b
	rr	c
	and	00011111b
	call	wrdata
	ld	de, msg_mb
	jp	MSG			; Mb
;
;------------------------------------------------------
;
initialize_ide:
        ld      hl, MasterInfo          ; clear Master,Slave structures
        ld      (hl), 0
        ld      d, h
        ld      e, l
        inc     de
        ld      bc, var_end-var_beg
        ldir    
	ld	a, (drv_sign)
	and	1
	jp	nz, cold_sd		; if key "SD" specified (if drv_sign=1)
;
ini_ide:
;       ld      a, ide_dev_master       ; =0
;       ld      (DevMsk0), a            ; flag for Master device
        ld      a, ide_dev_slave        
        ld      (DevMsk1), a            ; flag for Slave device
	ld	hl, buffer+512
	ld	(buffer1), hl		; 512bytes byffer for Slave device
	ld	hl, buffer
	ld	(buffer0), hl		; 512bytes byffer for Master device

        call    ide_hard_reset          ; reset the drives
        ld      ix, MasterInfo
        ld      de, msg_m		; title: "Master: "
        call    drive_init              ; init and detect master drive
        push    af
	call	get_params
	pop	af
	push	af
	call	nz, drive_info		; print master drive information if exists
        ld      ix, SlaveInfo
        ld      de, msg_s		; title: "Slave: "
        call    drive_init              ; init and detect slave drive
	ld	b,0
	jr	z, NoSlave
	call	get_params
	call	drive_info		; print slave drive information
	ld	b,1
NoSlave:ld      ix, MasterInfo
        pop     af
	jr	z, NoMaster
	inc	b
NoMaster:push	bc
        call    nz, wr_lba              ; default master (if ready)
	ld	de, crlf
	call	msg
	pop	af			; a=count of detected IDE devices
	or	a
	ret
;
;------------------------------------------------------------------
; Routine that deternime how many "inc de" ops between two
; interrupts (i.e. in 20ms interval). At 3.5 MHz (5M Turbo+Wait)
; 1792 ops "complex decrement" (35 tstates) between two interrupts.
;
int20:
        ld      a, i
        ret     po             ; return if interrupts disabled
        halt                   ; wait for interrupt
;
ifirst: di
        ld      a,  (int50)
        ld      hl, (int50 +1)
        ld      (intbank), a
        ld      (intaddr), hl
        ld      a, (MARKER)
        ld      (int50), a
        ld      hl, isecond        ; second interrupt start address
        ld      (int50 +1), hl
        ld      hl, 0
        ei
ifirst2:ld      a, (intflag)                        ; 13 tstates
        inc     hl                                  ; 6
        nop                                         ; 4
        or      a                                   ; 4
        jr      z, ifirst2    ; wait for interrupt  ; 12  total=39 tstates
        di
        ld      a, h
        scf
        ccf
        rra                   ; divide by 2 - for 10ms timing
        ld      h, a
        ld      a, l
        rra
        ld      l, a
        ld      (intinchl), hl
        ld      a, (intbank)
        ld      hl, (intaddr)
        ld      (int50), a
        ld      (int50 +1), hl
        ei
        ret
;
isecond:ld      a, 1
        ld      (intflag), a
        ret
;
;
; do the identify drive command, and return with the buffer
; filled with info about the drive
;
drive_id:
        call    ide_wait_not_busy
        jp      z, rdy_err
        ld      a, (ix)                 ; MasterFlag from DriveInfo
        and     ide_dev_slave
        or      10100000b
;        ld      l, a
;        ld      a, ide_head
;       call    ide_wr_8                ;select device
		out	(portIdeHead),a
		call    ide_wait_ready
        jp      z, get_err
;        ld      a, ide_command
;        ld      l, ide_cmd_id
;        call    ide_wr_8                ;issue the command
		ld	a,ide_cmd_id
		out	(portIdeCom),a
        call    ide_wait_drq
        jp      z, get_err
        rrca
        jp      c, get_err
        ld      l, (ix+3)
        ld      h, (ix+4)
;
read_data:
;       ld      bc, ide_data            ; b=0,  c = ide register address
;@@P1:   ld      de, ide_8255_ctl
;rdblk2: ld      a, c
;        ld      (de), a                 ; drive address onto control lines
;        or      ide_rd_line 
;        ld      (de), a                 ; assert read pin on control lines
;        ld      a, (hl)                 ; delay 7 tstates ~2 mks at 3.5MHz
;@@P2:	ld      a, (ide_8255_lsb)       ; read the lower byte
;       ld      (hl), a
;       inc     hl
;@@P3:	ld      a, (ide_8255_msb)       ; read the upper byte
;        ld      (hl), a
;        inc     hl
;        xor     a
;        ld      (de), a                 ; deassert all control pins
;        djnz    rdblk2
		ld	b,0
rdblk2:	
		in	a,(portIdeDataL)
		ld	(hl),a
		inc	hl
		in	a,(portIdeDataH)
		ld	(hl),a
		inc	hl
		djnz	rdblk2
		xor	a
        ret
;           
;
; initialize the ide drive. Return Z if NOT_READY, NZ if OK
;
ide_init:
	call	MDI
        ld      a, (ix)                 ; MasterFlag from DriveInfo
        and     ide_dev_slave
        or      10100000b
;        ld      l, a
;        ld      a, ide_head
;        call    ide_wr_8                ;select the master device
		out	(portIdeHead),a
        call    ide_wait_ready
	call	MEI
        jr      nz, ide_ini1
        call    rdy_err
        xor     a
        ret
ide_ini1:
        ld      a, (ix+22)              ; if flag, make recalibrate (for old HDDs)
        or      a
        jr      nz, ide_ini2
        inc     a                       ; 1, NZ
        ret
ide_ini2:
        ; uncomment this section if you have a very old hard drive
        ; (probably win3.1 or early win95 era) that does not even
        ; allow LBA accesses until these CHS parameters are set up
        ;mov    a, #ide_head
        ;mov    r2, #10101111b
        ;call  ide_wr_8                ;what should this config parm be?
        ;mov    a, #ide_sec_cnt
        ;mov    r2, #64
        ;call  ide_wr_8                ;what should this config parm be?
        ;mov    a, #ide_command
        ;mov    r2, #ide_cmd_init
        ;call  ide_wr_8                ;do init parameters command
        ;call  ide_wait_not_busy
        ;mov    a, #ide_command

;        ld      a, ide_command
;        ld      l, ide_cmd_recal
;        call    ide_wr_8                ;ask the drive to read it
		ld	a,ide_cmd_recal
		out	(portIdeCom),a
        jp      ide_wait_not_busy       ;make sure drive is ready
;
;
; Hard reset on the drive, by pulsing its reset pin.
; this should usually be followed with a call to "ide_init".
;
ide_hard_reset:
;        ld      a, rd_ide_8255
;@@P4:	ld      (ide_8255_cfg), a           ;config 8255 chip, read mode
 ;       ld      a, ide_rst_line
;@@P5:	ld      (ide_8255_ctl), a       ;hard reset the disk drive
;        call    delay10
 ;       xor     a
;@@P6:   ld      (ide_8255_ctl), a       ;no ide control lines asserted
		ld	a,8	; soft reset
		out	(portIdeCom),a
		xor	a
	ret
;
;
; First time drive initialization. Input: IX=DriveInfo_array, DE=title
; Return Z if NOT_READY, NZ if OK
;
drive_init:
        call    msg
        call    ide_init
        ret     z
	call	MDI
        call    drive_id
	call	MEI
        ld      l, (ix+3)
        ld      h, (ix+4)
        push    hl
        pop     iy              	; iy=buffer, ix=DriveInfo
	ld	a, (iy+120)	
	ld	(ix+14), a
	ld	a, (iy+121)	
	ld	(ix+15), a
	ld	a, (iy+122)	
	ld	(ix+16), a
	ld	a, (iy+123)		; capacity for LBA-supported IDEs
	ld	(ix+17), a	        ; convert Low-Endian to Big-Endian
        ld      a, (iy+99)		; capabilities
        and     2
	push	af
        ld      (ix+1), a               ; LBA or CHS mode
        ld      c, (iy+2)
        ld      (ix+9), c
        ld      b, (iy+3)
        ld      (ix+10), b              ; MaxCyl
	push	bc
        ld      b, (iy+6)
        ld      (ix+11), b              ; MaxHead (HPT)
        ld      e, (iy+12)
        ld      (ix+12), e
        ld      d, (iy+13)
        ld      (ix+13), d              ; MaxSec (SPT)
        ld      hl, 0
drvinit:add     hl,de
        djnz    drvinit                 
        ld      (ix+18), l
        ld      (ix+19), h              ; hl=HmulS=HPT*SPT
	ex	de,hl			; de=HPT*SPT
	pop	bc			; bc=CYL
	pop	af
	ret	nz			; LBA -> yes (nz)
	call	MULT32A			; DEHL=DE*BC=HPT*SPT*CYL. hi D15..E0.H15..L0 lo
        ld	(ix+14), l
	ld	(ix+15), h
	ld	(ix+16), e
	ld	(ix+17), d		; max sector N (for non-LBA)
	ld	a, 1
	or	a
	RET


ess then 'A'
	cp	'G'
	jr	nc, shex0	; greater then 'F'
shexit: or	a		; NZ
	ret
;
sdec0:	inc	hl
see