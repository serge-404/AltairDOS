




                       Программное обеспечение ПЭВМ


                          Макроассемблер  M80


                         Руководство программиста
.PA

			Содержание

                 1. Макроассемблер M80
                 ---------------------

1.1.      Назначение и условия применения макроассемблера.... 3
2.	  Элементы и основные конструкции языка.............. 3
2.1.	  Основные элементы языка............................ 3
2.1.1.	  Символы............................................ 3
2.1.2.	  Числа, константы и строки.......................... 3
2.1.3.	  Символические имена................................ 4
2.2.   Выражения............................................... 4
2.2.1.	  Арифметические и логические операции............... 4
2.2.2.	  Абсолютные и перемещаемые имена.................... 5
2.2.3.	  Внешние ссылки..................................... 5
2.3.   Синтаксис ассемблерных предложений...................... 6
2.3.1.	  Метка.............................................. 6
2.3.2.	  Оператор........................................... 6
2.3.3.	  Операнды и примечания.............................. 6
2.4.   Псевдокоманды........................................... 7
2.4.1.	  Псевдокоманды перемещения.......................... 7
2.4.1.1.    ASEG............................................... 7
2.4.1.2.    COMMON............................................. 7
2.4.1.3.    CSEG............................................... 7
2.4.1.4.    DSEG............................................... 8
2.4.2.	  DB - Определить байт............................... 8
2.4.3.      DC - Определить символ............................. 8
2.4.4.	  DS - Определить область............................ 8
2.4.5.	  DW - Определить слово.............................. 9
2.4.6.	  END................................................ 9
2.4.7.	  ENTRY/PUBLIC........................................9
2.4.8.	  EQU.................................................9
2.4.9.	  EXT/EXTRN..........................................10
2.4.10.	  INCLUDE............................................10
2.4.11.	  NAME...............................................10
2.4.12.	  ORG - Задать счетчик адреса........................10
2.4.13.	  PAGE...............................................11
2.4.14.	  SET................................................11
2.4.15.     TITLE..............................................11
2.4.16.	  SUBTTL.............................................11
2.4.17.	  .COMMENT...........................................11
2.4.18.	  .PRINTX............................................12
2.4.19.	  .RADIX.............................................12
2.4.20.	  .REQUEST...........................................12
2.4.21	  Условные псевдокоманды.............................13
2.4.21.1.   ELSE...............................................13
2.4.21.2.   ENDIF..............................................13
2.4.22.     Псевдокоманды управляющие выводом листинга.........14
2.4.23.	  Перемещение перед загрузкой........................14
2.5.        Макрокоманды и блоки...............................15
2.5.1.	  Терминология.......................................15
2.5.2.	  Блок REPT-ENDM.....................................15
2.5.3.	  Блок  IRP-ENDM.....................................15
2.5.4.	  Блок IRPC-ENDM.....................................16
2.5.5.	  MACRO..............................................16
2.5.6.	  EXITM..............................................17
2.5.7.	  LOCAL..............................................17
2.5.8.	  Специальные макрооператоры и формы.................18
3.          Руководство по эксплуатации компилятора M80........20
3.1.        Обращение к компилятору. Входные и выходные данные.20
3.2.        Ключи компиляции...................................21
3.3.        Формат листинга....................................21
3.4.        Сообщения об ошибках...............................22

4.          Программа вывода перекрестных ссылок - CREF........24

5.          Компоновщик L80....................................25

5.1.        Назначение компоновщика............................25
5.2.        Обращение к компоновщику...........................25
5.3.        Ключи компоновки...................................26
5.4.        Сообщения об ошибках...............................28

6.          Библиотекарь LIB...................................29

6.1.        Назначение библиотекаря............................29
6.2.        Обращение к библиотекарю...........................29
6.3.        Задание файлов источников..........................29
6.4.        Ключи библиотекаря.................................30
6.5.        Сообщения выдаваемые библиотекарем.................31

                 Приложение 1
                 ------------
            Команды микропроцессора КР580ВМ80а.................32

                 Приложение 2
                 ------------
            Коды команд микропроцессора КР580ВМ80А.............34

                 Приложение 3
                 ------------
            Описание команд мп КР580ВМ80А......................36

                 Приложение 4
                 ------------
            Пример программы копирования файлов................42

                 Приложение 5
                 ------------
            Пример программы распечатки файла
            в шестнадцатиричной форме..........................47



                    1. Макроассемблер - M80
                    -----------------------

     1.1. Назначение и условия применения макроассеблера

     Макроассемблер - это компилятор с символического машинно-
ориентированного языка (языка ассемблера). Он преобразует исходную
программу, написанную на языке макроассемблера, в перемещаемый модуль.
В дальнейшем с помощью компоновщика L80 модуль может быть скомпонован
(один или с другими модулями) в программу, готовую к выполнению.

     Применение макросредств позволяет наиболее часто встречающиеся
участки программы оформлять в виде макрокоманд.

     Использование макроассемблера значительно облегчает написание
программ и позволяет наиболее эффективно использовать все ресурсы ЭВМ.

     Макроассемблер находится на диске в виде файла с именем M80.COM.

     2. Элементы и основные конструкции языка

     2.1. Основные элементы языка

     2.1.1. Символы

     Все сложные элементы языка M80 формируются из символов.
В качестве символов могут использоваться:
     -буквы латинского алфавита от A до Z ;
     -цифры от 0 до 9 ;
     -специальные символы + - , : ; ( ) ' # $ пробел ;

     2.1.2. Числа, константы и строки

     Числа - это беззнаковые 16-битные величины.  Число всегда
вычисляется в системе счисления по умолчанию, если оно не задано в
специальном виде:

    NNNNNNNN B        - двоичное    ( где N - 0 или 1 )

    NNNN O или NNNN Q - восьмеричное ( где N - 0...7 )

    NNNN H Или NNNN X - шестнадцатиричное ( где N - 0...9,
                        A,B,C,D,E,F ),Если первый символ
                        не цифра,то перед ним должен стоять 0
                        0NNNN H или 0NNNN X

     По умолчанию все числа считаются в десятичной системе счисления.
Этот режим можно изменить. С помощью команды .RADIX можно выбрать
любое основание системы счисления от 2 до 16.  Переполнение при
вычислении числа игнорируется и значащими являются младшие 16 бит.

     Символьная константа - это строка, содержащая один или два
символа в апострофах.

     Значением символьной константы, содержащей один символ, является
величина численного значения соответствующего кода, принятого в
операционной системе (ОС) CP/M. Например, значением константы "A"
будет 41H.

     Значением символьной константы, содержащей два символа, будет
двухбайтовое число, причем в старшем байте будет значение первого
символа, а в младшем байте - значение второго символа.  Например,
значением константы "AB" будет число 41H*256+42H.

     Строка - это набор символов, заключенных в кавычки или апострофы.
Кавычки также могут быть элементом строки, но при этом они должны
удваиваться. Например, предложение

        DB "я""иду""гулять"

запомнит строку

       я"иду"гулять

     Если между кавычками нет символов, то такая строка будет
пустой строкой.

     2.1.3. Символьные имена

     Символические   имена  могут  содержать  любое  количество
символов,  но  значащими являются первые 6 символов.  В  именах
допустимы следующие символы:

     Буквы от A до Z , цифры от 0 до 9 , $ , . , ? , @

Символическое имя не может начинаться с цифры.
     При обработке имен буквы из нижнего регистра переводятся в
буквы верхнего регистра.


     2.2. Выражения

     2.2.1. Арифметические и логические операции

     В выражениях допустимы следующие операции, приведенные в
порядке убывания приоритета их выполнения.

	NUL
	LOW,HIGH
	*,/,MOD,SHR,SHL
	Унарный минус
	+,-
	EQ,NE,LT,LE,GT,GE
	NOT
	AND
	OR,XOR

     Для изменения порядка выполнения операций надо использовать
скобки.  При вычислении выражений сначала выполняются операции,
имеющие более высокий приоритет.  Все подвыражения, содержащие
операции с более высоким приоритетом, вычисляются в первую очередь.

     Все операции , кроме +,-,*,/, должны быть отделены от операндов
по крайней мере одним пробелом.  Операции выделения байта (HIGH,LOW)
выделяют старшие или младшие 8 бит из абсолютной 16-битной величины.
Если в качестве операнда используется перемещаемая величина, то HIGH и
LOW интерпретируются как операции, работающие с адресом ноль.

     2.2.2. Абсолютные и перемещаемые имена

     Все символические имена, используемые в качестве операндов в
выражениях, есть либо абсолютные имена, либо перемещаемые имена.
Перемещаемые имена подразделяются на программные перемещаемые имена,
перемещаемые имена данных и COMMON (п.2.4.1.).

     Все символические имена, ассемблированные для псевдокоманд ASEG,
CSEG (по умолчанию) или DSEG, относятся к абсолютным, перемещаемым
программным или перемещаемым данным соответственно.  Количество имен
COMMON в программе зависит от числа блоков COMMON, поименованных в
программе с помощью псевдокоманды COMMON.  Два символических имени
COMMON считаются разными, если они присутствуют в разных блоках
COMMON.

     При любой операции, кроме сложения и вычитания, оба операнда
должны быть абсолютными.

     Для сложения применяются следующие правила:

1) по крайней мере один из операндов должен быть абсолютным;
2) абсолютное + перемещаемое = перемещаемое.

     Для вычитания действуют правила:

1) перемещаемое - абсолютное = перемещаемое;
2) перемещаемое - перемещаемое = абсолютное,

причем в 2) оба имени должны быть перемещаемыми именами одного типа.

     Для каждого промежуточного шага при вычислении выражения должны
выполняться вышеуказанные правила, иначе будет выдано сообщение об
ошибке.  Например, если FOO,BAZ и ZAZ - три символических перемещаемых
имени, то выражение:

	FOO + BAZ - ZAZ

выработает сообщение об ошибке, т.к. на первом шаге будут складываться
два перемещаемых имени.  Этого можно избежать,используя скобки:

	FOO + (BAZ - ZAZ)

     2.2.3. Внешние ссылки

     Символическое имя может быть внешним (EXTRN) или нет (см. п.
2.2.9.). Внешнее имя ассемблируется в 2 байта.  При использовании
внешних имен в выражениях должны выполняться следующие правила:

1) EXTRN допустимы только при сложении и вычитании;
2) если в выражении используется имя типа EXTRN,
   то результат всегда будет EXTRN;
3) при сложении любой операнд (но не оба одновременно)
   может быть EXTRN;
4) при вычитании только первый операнд может быть EXTRN.

     2.3. Синтаксис ассемблерных предложений

     Ассемблерная программа состоит из последовательности предложений.
Каждое предложение имеет следующую структуру:

	метка: (оператор) (операнды) ;примечание

     Совсем необязательно, чтобы предложение начиналось с метки.


     2.3.1. Метка

     Метка - это символическое имя, после которого следует двоеточие.
Если метка присутствует, то она должна быть первым элементом
предложения.  Значение метки есть текущее значение счетчика адреса.
Если после метки стоят два двоеточия, то такая метка объявляется
внутренней (PUBLIC) и к ней можно обращаться из другой программы.


     2.3.2. Оператор

     Следующим элементом после метки или первым, если нет метки идет
оператор. В качестве оператора может быть:

     1) мнемокод микропроцессора КР580ВМ80А ;
	2) макровызов ;
	3) псевдокоманда ;
	4) выражение.

     Если в поле оператора стоит выражение, то ассемблер рассматривает
его как псевдокоманду DB.

     2.3.3. Операнды и примечания

     следующим элементом предложения являются операнды. В зависимости
от оператора в поле операндов может быть один, два или несколько
операндов.

     В качестве операндов можно использовать мнемокоды команд
микропроцессора КР580ВМ80А.  При этом следует учитывать, что
допустимым операндом будет только первый байт команды.

     Пример.

	MVI A,JMP
	ADI CPI
	MVI B,RNZ
	CPI INX H
	ACI LXI B
	MVI C,MOV A,B

     Если в операнд будет включено более одного байта (CPI 5,
LXI B,LAM,JMP A5), то будет выдано сообщение об ошибке.

     Примечания являются последним элементом предложения.  Примечания
всегда начинаются с символа ; и заканчиваются CR (ВК).

     2.4. Псевдокоманды

     2.4.1. Псевдокоманды перемещения

     Отличительной особенностью макроассемблера M80 является создание
им перемещаемых модулей.  Перемещаемость модуля облегчает его отладку
и тестирование, позволяет компоновать программу из нескольких модулей,
написанных на разных языках.  Кроме того, программу можно разбивать на
сегменты и указать, какие сегменты должны размещаться только в ОЗУ
(сегменты данных), а какие могут быть занесены в пзу (сегменты
содержащие программу).  Эти сегменты создаются с помощью псевдокоманд
DSEG и CSEG.  Псевдокоманда ASEG используется при создании
неперемещаемых (абсолютных) кодов. Псевдокоманда COMMON создает общие
области данных для каждого поименованного в программе блока COMMON.

     Для каждого сегмента программы ASEG, CSEG или DSEG заводится свой
счетчик адреса, который приостанавливает отсчет при смене типа
сегмента и возобновляет отсчет, когда снова встречается
соответствующий сегмент. Значение счетчика адреса в любом сегменте
можно изменить с помощью псевдокоманды ORG (п.2.4.12).  По умолчанию
всегда действует пседокоманда CSEG.

     2.4.1.1. ASEG

     Формат псевдокоманды:

	ASEG

     ASEG устанавливает значение счетчика адреса на абсолютный сегмент
в памяти.  Значение счетчика будет продолжением предыдущего ASEG (по
умолчанию 0), если после ASEG не стоит ORG.


     2.4.1.2. COMMON

     Формат псевдокоманды:

     COMMON /"имя блока"/

     COMMON устанавливает счетчик адреса на адрес выбранного общего
блока памяти. Для совместимости с оператором COMMON в фортране этот
адрес всегда указывает на начало области. Если "имя блока" опущено или
состоит из пробелов, то блок COMMON считается пустым.


     2.4.1.3. CSEG

     Формат псевдокоманды:

     CSEG


     CSEG устанавливает значение счетчика адреса на смещение
относительно начала сегмента памяти, содержащего коды команд.
Значение адреса будет соответствовать значению предыдущего CSEG (по
умолчанию 0), если только после CSEG не стоит псевдокоманда ORG. Для
ассемблера CSEG является псевдокомандой по умолчанию.

  2.4.1.4. DSEG

     Формат псевдокоманды:

     DSEG

     DSEG устанавливает значение счетчика сегмента адреса на
относительный адрес сегмента памяти, содержащего данные.  Значение
адреса будет соответствовать адресу последнего DSEG (по умолчанию 0),
если не было псевдокоманды ORG.


     2.4.2. DB - определить байт

     Формат псевдокоманды:

     DB "выражение","выражение",...   Или
     DB "строка" ["строка"...]

     Аргументами для DB могут быть выражения или строки. DB запоминает
значения выражений или символов в строках в последовательных адресах
памяти, начиная с адреса, указанного в счетчике адреса. Значение
выражения должно помещаться в одном байте. Если старший байт
результата 0 или 255, то сообщение об ошибке не выдается. В противном
случае выдается ошибка A.

     В выражениях не могут присутствовать строки, содержащие более 2-х
символов.  Старший бит каждого байта, отведенного под соответствующий
символ, равен нулю.

	Примеры:

	0000'  41 42     DB 'AB'
	0002'  42        DB 'AB' AND 0FFH
	0003'  41 42 43  DB 'ABC'


     2.4.3. DC - определить символ


     Формат псевдокоманды:

     DC "строка"

     DC запоминает символы,заданные в "строке",последовательно,
начиная с адреса, указанного в счетчике адреса. В отличие от DB
в байте,  содержащем последний символ строки, в старшем разряде
стоит 1. Если строка пустая, то выдается сообщение об ошибке.


     2.4.4. DS - определить область

     Формат псевдокоманды:

     DS "выражение"

     DS резервирует область памяти.  Значение выражения показывает,
сколько байтов должно быть зарезервировано.  Все имена, присутствующие
в выражени, должны быть определены к моменту вычисления выражения при
первом проходе макроассемблера. В противном случае при первом проходе
появится флаг V, а при втором проходе - флаг U. Если при втором
проходе флаг U не появится, то все равно в модуле может быть ошибка,
т.к. DS обрабатывается при первом проходе.


     2.4.5. DW - определи)ть слово

     Формат псевдокоманды:

     DW "выражение","выражение",...

     DW последовательно записывает значения выражений в ячейки памяти,
начиная с адреса, содержащегося в счетчике адреса.  Значения выражений
есть дбухбайтовые величины.


     2.4.6. END

     Формат псевдокоманды:

     END "выражение"

     Оператор END указывает на конец программы.  Если присутствует
"выражение", то оно указывает на стартовый адрес программы.  Если
"выражение" отсутствует, то компоновщику L80 стартовый адрес не
передается.

     *) Примечание. Если ассемблерная программа является основной
        программой при компоновке, то в ней должен быть указан
        стартовый адрес.  В противном случае компоновщик L80 выдаст
        сообщение об ошибке "нет стартового адреса".  Если же
        ассемблерная программа является подпрограммой по отношению к
        программе, написанной, например, на Фортране, то стартовый
        адрес можно не задавать, т.к. он будет задан в основной
        программе.


     2.4.7. ENTRY/PUBLIC

     Формат псевдокоманды:

     ENTRY "имя","имя",...  Или
     PUBLIC "имя","имя",...

     ENTRY или PUBLIC объявляют все имена, присутствующие в списке,
как внутренние, доступные извне. После этого к таким именам можно
обращаться из других программ. Все имена в списке ENTRY/PUBLIC должны
быть определены, иначе будет сообщение об ошибке U. Имена, объявленные
ENTRY или PUBLIC, заносятся в список глобальных имен и используются
компоновщиком L80 при удовлетворении внешних ссылок.

     2.4.8. EQU

     Формат псевдокоманды:

     "имя" EQU "выражение"

     По команде EQU символическому имени присваивается значение
выражения.  Если "выражение" имеет EXTRN, то выдается сообщение об
ошибке.

     2.4.9. EXT/EXTRN

     Формат псевдокоманды:

     EXT "имя","имя",...   Или
     EXTRN "имя","имя",...

     EXT или EXTRN объявляют указанные имена внешними (EXTRN), т.е.
определенными в другой программе.  Если имя, указанное в списке,
определено в данной программе, то будет выдано сообщение об ошибке M.
Если заканчивается двумя знаками числа (##), то оно также объявляется
как внешнее.


     2.4.10. INCLUDE

     Формат псевдокоманды:

     INCLUDE "имя файла"

     Три псевдокоманды INCLUDE, $INCLUDE и MACLIB эквивалентны.
Псевдокоманда INCLUDE позволяет включать в текст исходной программы
программы, записанные в других файлах. "Имя файла" - это имя файла,
содержащего включаемую программу.  Тип файла должен быть .MAC.

     Файл, присутствующий в псевдокоманде INCLUDE, открывается и
транслируется в текущую программу сразу же за псевдокомандой INCLUDE.

     При выводе листинга в каждой строке, содержащей элемент
включенного файла, сразу же после кода команды стоит знак "+".

     Вложение псевдокоманд INCLUDE не допускается.  Если файл,
указанный в INCLUDE, не существует, то будет выдано сообщение об
ошибке "V" и данная псевдокоманда игнорируется.

     2.4.11. NAME

     Формат псевдокоманды:

     NAME ('имя программы')

     NAME задает имя программы.  Значащими в "имени" являются только
первые шесть знаков.  Имя можно задавать и с помощью псевдокоманды
TITLE. Если в программе отсутствует NAME и TITLE, то в качестве имени
берется имя исходного файла.


     2.4.12. ORG - Задать счетчик адреса

     Формат псевдокоманды:

     ORG "выражение"

     Счетчику адреса присваивается выражение.  Все имена в выражении
должны быть определены при первом проходе.

     2.4.13. PAGE

     Формат псевдокоманды:

     PAGE "выражение"

     Пседокоманда PAGE дает указание ассемблеру начать новую страницу
вывода листинга.  Если в псевдокоманде присутствует "выражение", то
оно задает число строк на странице.  Это число должно быть в диапазоне
от 1 до 255.  По умолчанию это число равно 50.


     2.4.14. SET

     Формат псевдокоманды:

     "имя" SET "выражение"

     SET осуществляет то же действие, что и EQU, но имя в
псевдокоманде SET может быть определено ранее.  Тогда после выполнения
SET имя будет переопределено.


     2.4.15. TITLE

     Формат псевдокоманды:

     TITLE "текст"

     TITLE задает заголовок программы, который может печататься в
первой строке каждой страницы. В тексте программы может быть только
одна псевдокоманда TITLE иначе будет сообщение об ошибке Q. Если не
задана псевдокоманда NAME, то первые шесть символов заголовка зададут
имя модуля.  Если в программе нет ни NAME, ни TITLE, то имя модуля
будет задано из имени исходного файла.


     2.4.16. SUBTTL

     Формат псевдокоманды:

     SUBTTL "текст"

     Эта псевдокоманда выводит заголовок после заголовка, выведенного
псевдокомандой TITLE.  Длина "текста" не должна превышать 60 знаков.
В программе может быть любое количество SUBTTL.

     2.4.17.  .COMMENT

     Формат псевдокоманды:

     .COMMENT "Разделитель""текст""разделитель"

     Первый символ, идущий после .COMMENT и отличный от пробела,
считается разделителем. Текст после разделителя считается примечаниями
и может занимать произвольное количество строк.  Примечания
заканчиваются, когда встречается второй разделитель - тот же самый
символ, который был использован в качестве первого разделителя.
     2.4.18.  .PRINTX

     Формат псевдокоманды:

     .PRINTX "Разделитель""текст""разделитель"

     Первый символ после .PRINTX, отличный от пробела, считается
разделителем. Текст, идущий после разделителя, во время трансляции
выводится на терминал до тех пор, пока не встретится второй
разделитель - тот же самый символ.

     *) Примечание. .PRINTX выводит листинг при каждом проходе
        ассемблера, поэтому, если листинг нужен только при одном
        каком-либо проходе,  то следует использовать псевдокоманды IF1
        или IF2.


     2.4.19.  .RADIX

     Формат псевдокоманды:

     .RADIX "Выражение"

     По умолчанию система счисления всех констант - десятичная.
Псевдокоманда .RADIX позволяет изменить основание системы счисления по
умолчанию (от 2 до 16).  "Выражение" в .RADIX всегда в десятичной
системе счисления независимо от основания системы счисления,
действующей в данный момент.


     2.4.20.  .REQUEST

     Формат псевдокоманды:

     .REQUEST "Имя файла","имя файла",...

     Эта псевдокоманда передает запрос компоновщику L80 на поиск
неудовлетворенных внешних имен в файлах, указанных в списке. Имена
файлов в списке не должны содержать типов файла и ссылок на диски. L80
ведет поиск файла с заданным именем и с типом .REL на диске по
умолчанию.


     2.4.21. Условные псевдокоманды

     Список условных псевдокоманд

   IF/IFT "выражение"    истина, если "выражение" не равно 0
   IFE/IFF "выражение"   истина, если "выражение" равно 0
   IF1                   истина при первом проходе
   IF2                   истина при втором проходе
   IFDEP "символ"        истина, если "символ" определен или объявлен 
                         EXTERNAL

   IFDEF "символ"        истина, если "символ" не определен и не 
                         объявлен EXTERNAL

   IFB "аргумент"        истина, если "аргумент" есть пробел.
                         Аргумент должен быть в угловых скобках

   IFNB "аргумент"       истина, если "аргумент" не пробел.
                         Используется для проверки некоторых
                         параметров. Аргумент должен быть в угловых 
                         скобках.

  IFIDN "Аргумент1",    истина, если строка "аргумент1" идентична
        "аргумент2"     строке "аргумент2". Аргументы должны быть в 
                        угловых скобках.

   IFDIF "Аргумент1",   истина, если строка "аргумент1" отличается от 
         "аргумент2"    строки "аргумент2".

     Все условные псевдокоманды имеют формат:

     IF XXX [аргумент]
     .
     .
     .
     [ELSE
     .
     .
     ]
     ENDIF

     Допускается вложение условных псевдокоманд, т.е.  псевдокоманда
внутри псевдокоманды.  Во избежание ошибок все аргументы условных
псевдокоманд должны быть известны при первом проходе.  Для IF, IFT,
IFF и IFE выражения должны содержать только определенные символы и все
выражения должны быть абсолютными.


     2.4.21.1.  ELSE

     В каждой условной псевдокоманде может присутствовать также
псевдокоманда ELSE, которая позволяет производить генерацию кодов,
если проверяемое условие есть ложь.  Для каждого IF допускается только
один ELSE, и каждый ELSE соответствует последнему открытому IF.

     2.4.21.2.  ENDIF

     Каждая псевдокоманда IF должна иметь соответствующую ей
псевдокоманду ENDIF, заканчивающую условие.

     2.4.22.  Псевдокоманды, управляющие выводом листинга

     Выводом листинга в файл можно управлять с помощью двух
псевдокоманд: .LIST и .XLIST

     Если листинг не выводится, то данные псевдокоманды игнорируются.

     По  умолчанию действует псевдокоманда .LIST,  инициирующая вывод
листинга. Если встречается псевдокоманда .XLIST, то вывод листинга
прекращается, пока не встретится псевдокоманда .LIST.

    Вывод условных блоков, имеющих значение ложь, употребляется
тремя псевдокомандами:

   .SFCOND      Подавление вывода условных блоков, имеющих значение 
                "ложь";

   .LFCOND      Восстановить вывод условных блоков, имеющих значение 
                "ложь";

   .TFCOND      Управлять выводом условных блоков, имеющих значение 
                "ложь", в зависимости от ключа /X.

     Вывод таблицы перекрестных управляется псевдокомандами .CREF И
.XCREF.  Если кросс-средства не используются, то эти псевдокоманды
игнорируются.  Условие по умолчанию - .CREF. Если встречается
псевдокоманда .XCREF, то вывод перекрестных ссылок прекращается до тех
пор, пока снова не встретится псевдокоманда .CREF.

     Вывод  расширений  MACRO/REPT/IRP/IRPC  управляется  тремя
псевдокомандами:

   .LALL    Выводит полный макротекст для всех расширений;
   .SALL    Выводит только сгенерированные объектные коды;
   .XALL    Выводит сгенерированные объектные коды и соответствующий 
            им текст (условие по умолчанию).



     2.4.23.  Перемещение перед загрузкой

     Перемещение перед загрузкой может задаваться с помощью двух
псевдокоманд: .PHAZE И .DEPHAZE Некоторые участки программ могут
находится в одной области, а выполняться лишь в другой, заданной,
области.

     Псевдокоманда  .PHAZE Обозначает начало такого участка,  а
псевдокоманда .DEPHAZE - Конец участка.

	Пример.

	0000'                  .PHAZE
	0100   CD 0106   F00:  CALL BAZ
	0103   C3 0007         JMP Z00
	0106   C9        BAZ:  RET
	0007'  C3 0005   Z00:  JMP 5

     Все метки внутри блока .PHAZE получают абсолютные значения в
зависимости от значения счетчика адреса .PHAZE. Коды, однако,
загружаются в текущую область памяти (т.е. с 0000' в этом примере).
Позже их можно переслать по адресу 100H и выполнить.

     2.5. Макрокоманды и блоки

     Макросредства ассемблера MACRO включают в себя три макрокоманды
повторения (REPT, IRP, IRPC) и операцию макроопределения (MACRO).
Каждая макрокоманда должна заканчиваться псевдокомандой ENDM.


     2.5.1. Терминология

     Для описания макрокоманд используются следующие термины:
1) "Фор.Пар." - Формальный параметр

   Все формальные парметры являются допустимыми символическими
   именами, которые появляются в теле макрорасширения;

2) "Список Форм.Пар." - Список формальных параметров, разделенных
   запятыми;

3) "список арг." - Список аргументов, разделенных запятыми.  Список
   аргументов всегда заключен в угловые скобки. Если в угловых скобках
   нет символа или между двумя запятыми нет символа, то это нулевой
   аргумент в списке.  При вложении угловых скобок (скобки в скобках)
   каждый внутренний уровень скобок удаляется при использовании
   соответствующего аргумента. Строка в кавычках является допустимым
   аргументом;

4) "список пар." - Список параметров, разделенных запятыми.


     2.5.2. Блок REPT-ENDM

     формат макрокоманды:

     REPT "выражение"
     .
     .
     ENDM

     Вычисляется значение "выражения" и группа предложений,
заключенная между REPT и ENDM, повторяется полученное число раз.
"Выражение" не может содержать внешние и неопределенные имена.

     Пример.

     X   SET    0
         REPT   10   ;Генерирует DB 1 - DB 10
     X   SET    X+1
         DB     X
         ENDM

     2.5.3. Блок IRP-ENDM

     формат макрокоманды:

     IRP "фор.Пар.",<Список арг.>
     .
     .
     .
     ENDM

     Число аргументов в списке определяет, сколько раз будет повторена
группа предложений, заключенная между IRP и ENDM. При каждом
повторении вместо всех вложений формального параметра подставляется
очередное значение из списка аргументов.  Если список аргументов пуст
(<>), то группа предложений обрабатывается 1 раз и формальный параметр
удаляется из всех вхождений.

     Пример.

     IRP   X, <1,2,3,4,5,6,7,8,9,10>
     DB    X
     ENDM

     Результат будет аналогичен предыдущему примеру.



     2.5.4. Блок IRPC-ENDM

     формат макрокоманды:

     IRPC  "Фор.Пар.",Строка (или "строка")
     .
     .
     .
     ENDM

     Количество знаков в строке указывает, сколько раз будет повторена
группа предложений между IRPC и ENDM. В данном случае угловые скобки
не обязательны.  При каждом повторении вместо формального параметра
будет подставляться очередной знак из строки.

     Пример.

     IRPC   X, 0123456789
     DB     X+1
     ENDM

     Результат аналогичен двум предыдущим примерам.


     2.5.5.  MACRO

     Формат макрокоманды:

     "имя" MACRO "список форм.Пар."
     .
     .
     .
     ENDM

     С помощью MACRO пользователь может создавать свои макрокоманды и 
помещать их в различные участки программы.

     "Имя" - это символическое имя, по которому впоследствии будут 
вызывать данную макрокоманду.

     "Список форм.пар." - это список парметров, которые будут
изменяться (замещаться фактическими параметрами) при каждом
вызове макрокоманды. Предложения между MACRO и ENDM составляют
тело макрокоманды.

     Форма обращения к макрокоманде следующая:

     "имя" "список пар."

Где  "имя" - это имя присвоенное MACRO в макроопределении;
     "список пар." - Это список фактических параметров, которые при 
     вызове макрокоманды заменят соответствующие формальные параметры.

     Если число фактических параметров превышает количество формальных 
параметров, то лишние фактические параметры игнорируются.  Если же 
число параметров меньше числа формальных параметров, то вместо 
недостающих фактических параметров будут подставлены нули.

     Пример.

     F00  MACRO  X
     Y    SET    0
          REPT   X
     Y    SET    Y+1
          DB     Y
          ENDM
          ENDM

     При обращении F00 10 эта макрокоманда сгенерирует те же
предложения, что и в предыдущих примерах.


     2.5.6. EXITM

     Псевдокоманда EXITM используется для завершения REPT/IRP/IRPC или 
вызова MACRO.  При выполнении EXITM макрорасширение немедленно 
выводится, а все оставшееся расширение или повторение не генерируется.  
Если блок, содержащий EXITM, входит в другой блок, то внешний уровень
продолжает расширяться.


     2.5.7. LOCAL

     Формат команды:

     LOCAL "список фор.Пар."

     Эта псевдокоманда допустима только внутри макроопределения MACRO.  
При выполнении LOCAL ассемблер создает уникальное символическое имя 
для каждого формального параметра из списка и подставляет потом это 
символическое имя при каждом вхождении данного формального параметра в 
макрорасширение.  Обычно, эти уникальные символические имена 
используются для задания меток внутри MACRO.  Это исключает 
возможность появления многократно определенных меток при неоднократных 
вызовах данной макрокоманды.  Символические имена, создаваемые при 
помощи LOCAL, находятся в диапазоне от ..0001 До ..FFFF.  Поэтому
пользователю в своих программах следует избегать имен типа ..NNNN. 
Если в макрокоманде есть LOCAL , то LOCAL должна быть в первом 
преложении макроопределения.


     2.5.8. Специальные макрооператоры и формы

     &   амперсанд используется для конкатенации текста или
         символических имен.  Формальный параметр, представляющий 
         собой строку в апострофах, не будет заменен в расширении, 
         если перед ним не будет стоять амперсанд.  Для образования 
         символического имени из текста и формального параметра между 
         ними надо поставить &.

     пример.

     ERG    MACRO   X
     ERROR&X: PUSH   BX
              MVI    BX,'&X'
              JMP    ERROR
              ENDM


     В этом примере вызов ERG A создаст следующую последовательность 
предложений:

     ERROR&A: PUSH B
              MVI B,'A'
	      JMP ERROR

     *) Примечание. Два символических имени считаются одинаковыми, 
если одно имя отличается от другого только наличием амперсанда.  Так
символическое имя ERRORA эквивалентно имени ERROR&A.

     ;;    Если в макрокоманде перед комментариями стоят две точки с 
           запятой, то эти коментарии не появляются в макрорасширениях 
           даже, если есть указание .LALL;

     $     Ссылка на текущее значение счетчика адреса;

     !     Символ, стоящий после восклицательного знака вводится 
           литерально;

     NUL   Это оператор, возвращающий значение "истина", если его 
           аргумент есть нуль.  Остаток строки после NUL
           рассматривается как аргумент для NUL. Условие IF NUL
           аргумент будет "ложным", если при расширении первый символ 
           аргумента будет отличен от точки с запятой или "CR" (вк).  
           Этот оператор рекомендуется использовать для проверки 
           наличия нулевых параметров в условных псевдокомандах IFB и 
           IFNB;

     %    Этот оператор может использоваться только в аргументе
          макрокоманды.  % преобразует следующее за ним выражение 
          (обычно символическое имя) в число в текущей системе 
          счисления.  Во время макрорасширения полученное число 
          подставляется в формальный параметр.  Использование % 
          позволяет вызывать макрокоманду с числом (обычно макровызов 
          - это вызов с текстом из аргументов).  Выражение, следующее 
          за %, должно удовлетворять тем же требованиям, что и в
          псевдокоманде DS.

	Пример.

     Нормально LB, являющееся аргументом для MACLAB, должно было 
подставляться аргументом MACRO. % преобразует LB в число и вместо Y 
подставляется уже число.  Без % результат трансляции был бы 'ERROR 
LB'.

	MACLAB MACRO  Y
	ERR&Y: DB 'ERROR &Y',0
	       ENDM
	MACERR MACRO X
	LB     SET 0
	       REPT X
	LB     SET LB+1
	       MACLAB %LB
	       ENDM
	       ENDM

     После макровызова MACERR  3 получим:

	ERR1: DB 'ERROR 1',0
	ERR2: DB 'ERROR 2',0
	ERR3: DB 'ERROR 3',0

  TYPE    Оператор TYPE возвращает байт, который описывает две
          характеристики аргумента:  перемещаемость и является ли 
          аргумент внешним (EXTRN) или нет.  Аргументом для TYPE может 
          быть любое выражение (строковое, числовое, логическое). Если 
          выражение неверно, то TYPE вернет ноль. Структура 
          возвращаемого байта следующая:  младшие два бита определяют 
          перемещаемость аргумента следующим образом:

            0   абсолютный;
	    1   программный перемещаемый;
	    2   данных перемещаемый;
	    3   COMMON перемещаемый.

          Старший бит (80H) - бит EXTRN.  Когда выражение содержит 
          внешний символ, то бит равен 1.  Бит определенности - (20H).  
          Когда выражение определено, то этот бит равен 1.  Если же 
          выражение не определено или содержит EXTRN, то этот бит 
          равен 0. TYPE Обычно используют внутри макрокоманд, когда 
          необходимо проверить тип аргумента.


         3. Руководство по эксплуатации компилятора M80

     3.1. Обращение к компилятору. Входные и выходные данные

     Исходными данными для компилятора является файл, содержащий 
программу написанную на макроассемблере и имеющий тип MAC.  В 
результате работы компилятор создает файл типа REL, содержащий модуль 
в перемещаемой форме.  Кроме того, по желанию пользователя может быть 
создан файл с листингом и файл перекрестных ссылок.

     Загрузка и запуск макроассемблера осуществляется одной из
следующих команд:

	1)	M80
	2)	M80 "командная строка"

     В режиме (1) M80 выводит на экран промпт "*" и ждет ввода
командной строки. В режиме (2) командная строка вводится сразу
после имени M80.

     Формат командной строки:

     "имя 1","имя 2"="имя 3"

где   "имя 1" - имя файла, в который будет записан перемещаемый 
       модуль;

      "имя 2" - устройство, на которое будет выводится листинг.Таким 
      устройством может быть консоль (TTY:), логическое устройство 
      (LST:) или файл на диске;

       "имя 3" - имя файла, содержащего исходный текст программы.

     Если "имя 1" и "имя 2" опущены, то по умолчанию берется имя файла 
исходного текста. Тип файла в "имя 1" всегда REL, в "имя 2", если 
задан файл всегда PRN, а в "имя 3" всегда MAC.  Если перемещаемый 
модуль и листинг не нужны, то слева от знака равенства надо поставить 
запятую.

     Примеры:

   *=SOURSE.MAC       Транслировать программу SOURSE.MAC И поместить 
                      объектный код в файл SOURSE.REL

   *,LST:=TEST        Транслировать программу TEST.MAC И вывести 
                      листинг на устройство LST;

   *SMALL,TTY:=TEST   Транслировать программу TEST.MAC, объектный файл 
                      записать в SMALL.REL, а листинг вывести на 
                      консоль.



     3.2. Ключи компиляции

     В командной строке может быть задано несколько ключей, которые 
будут влиять на формат выводимого листинга.

     Ключ                   действие
     ----                   --------
      /O      печатать в листинге все адреса и т.п. в восьмеричной 
              системе счисления

      /H      печатать в листинге все адреса и т.п. в
              шестнадцатиричной системе счисления (действует по
              умолчанию)

      /X     подавить вывод листинга условий, значение которых есть 
             "ложь"

      /P    создать объектный файл

      /L    создать файл с листингом

      /C    создать файл перекрестных ссылок


       пример.

       *=TEST/L/P      Оттранслировать файл TEST.MAC. Объктный код 
                       выводить в файл TEST.REL, а листинг - в файл 
                       TEST.LST.


     3.3. Формат листинга

     на каждой странице листинга первые две строки содержат:

	[TITLE текст]      MACRO        PAGE  X [-Y]
	[SUBTITLE текст]

   где  TITLE текст - текст заданный псевдокомандой TITLE; X - 
        основной номер страницы. Он увеличивается только при появлении 
        из исходного файла символа подачи новой страницы. Когда 
        печатается таблица символов X=S; Y - младший номер страницы. 
        Он увеличивается при появ- лении псевдокоманды PAGE или при 
        заполнении текущей страницы;

        SUBTITLE текст- текст,заданный псевдокомандой SUBTITLE.  После 
        вывода этих двух строк выводится одна пустая строка, а затем 
        очередная строка программы. Строка программы имеет вид:

    [CRF#]   [ERROR]   LOC#M   !XX!XXXX! ......  Исходный текст

     Если выводится таблица перекрестных ссылок, то первый элемент в 
строке - номер для таблицы, после него стоит символ табуляции.

     ERROR - Это флаг ошибки, если в строке есть ошибка. Если в
стороке нет ошибки, то вместо ERROR стоит пробел. Если таблица
перекрестных ссылок не создается, то флаг ошибки стоит в первой
колонке.

     LOG#M - Значение счетчика адреса, которое в зависимости от ключей 
/M или /0 представляет собой 16-е число, содержащее 4 цифры, или 8-е 
число, содержащее 6 цифр. Символ после числа - это индикатор 
перемещаемости:

	'	 программный перемещаемый;
	"	 данных перемещаемый;
	!	 COMMON перемещаемый;
     пробел      абсолютный;
	*	 внешний.

     Далее печатаются три пробела, после которых идет код команды и 
операндов (если они есть у данной команды). Если строка листинга 
появилась из файла, включенного по псевдокоманде INCLUDE, то после 
кодов идет буква C. Если строка содержит макрорасширение (MACRO, REPT, 
IRP, IRPT), то после кодов стоит знак "+". Остаток строки содержит 
исходный текст.

     В конце листинга выводится таблица символических имен.  Сначала в 
алфавитном порядке печатаются имена всех макрокоманд, после этого 
выводятся все символические имена программы.  После каждого 
символического имени выводится знак табуляции, а затем печатается 
значение символического имени. Если имя типа PUBLIC, то после его 
значения печатается буква I. Далее печатается один из следующих 
знаков:

	U	имя неопределено;
	C	имя блока COMMON;
	*	внешнее имя;
     пробел     абсолютное имя;
	'	программный относительный;
	"	данных относительный;
	!	COMMON относительный.


     3.4. Сообщения об ошибках

     Сообщения об ошибках индицируются одной буквой (флагом) в первой 
колонке листинга. Если файл с листингом не выводится на консоль, то 
ошибочные строки все равно выводятся.

     Флаг       Значение
	----		 --------
      A   Ошибка в аргументе.  Неправильный формат аргумента 
          псевдокоманды или аргумент вне допустимых границ.

      C   Ошибка условного вложения. ELSE без IF; ENDIF без IF; два 
          ELSE на один IF.

	 D	Многократно определенное символическое имя.

      E   Ошибка при использовании EXTRN.  Недопустимое использование 
          символического имени, объявленного EXTRN.

	 M	Многократно определенное символическое имя.

      N   Ошибка в числе.  Неверное задание числа (например 8Q).

      O   Неверный код операции или ошибочный синтаксис. ENDM, LOCAL 
          вне блока; SET, EQU или MACRO без имени; неверный синтаксис 
          в коде команды; неверный синтаксис в выражении.

      P   Ошибка фазы.  Значение метки или имени в EQU изменилось при
		втором проходе.

      Q   Вопрос.  Обычно означает, что строка окончена неверно.
		Это предупреждение о возможной ошибке.

      R   Перемещение.  Недопустимое использование перемещения в 
          выражении.

 	 U	Неопределенное символическое имя.

	 V	Ошибка значения.
          При первом проходе псевдокоманда не может получить 
          необходимого определенного значения. Если символ, 
          встретившийся в псевдокоманде, определен ниже, то при втором 
          проходе ошибка U выдаваться не будет.

     Кроме флагов компилятор выдает следующие сообщения об ошибках:

  'NO END STATEMENT ENCOUNTED ON INPUT FILE '
  Нет оператора END

  'UNTERMINATED CONDITIONAL'
  по меньшей мере один условный блок не завершен до конца файла

  'UNTERMINATED REPT/IRP/IRPC/MACRO'
  по меньшей мере один блок не завершен

  [XX]  [NO]  FATAL ERROR(S)  [,XX WARNINGS]
  количество серьезных ошибок и предупреждений.  Это сообщение всегда 
  выводится на консоль и в файл с листингом



     4. Программа вывода перекрестных ссылок - CREF

     Для создания листинга с перекрестными ссылками сначала компилятор 
M80 должен создать специальный файл.  MACRO создает этот файл, если 
задан ключ /C.  При задании ключа /C вместо файла .LST компилятор 
создает файл типа .CRF.  После того, как M80 закончит трансляцию, надо 
загрузить программу CREF.

     После загрузки CREF выводит на экран запрос * и ждет ввода
командной строки. Формат командной строки для CREF:

     * лист.файл = исх.файл

     По умолчанию тип исходного файла - .CRF. После этого CREF создает 
файл типа .PRN, содержащий таблицу перекрестных ссылок. Листинг такого 
файла отличается от стандартного следующим:

   - каждое предложение начинается с номера;
   - в конце листинга в алфавитном порядке печатаются все
     символические имена с номерами тех строк, где они встретились.  
     Номер строки, в которой данное символическое имя определено, 
     отмечается знаком #.


                  5. Компоновщик - L80
                  --------------------

   5.1. Назначение компоновщика

     Компоновщик создает из перемещаемых модулей программы, готовые к 
выполнению.  Перемещаемые модули получаются в результате трансляции 
программ, написанных на различных языках программирования.

   5.2. Обращение к компоновщику

     Компоновщик находится на диске в виде файла L80.COM И может быть 
инициализирован одной из следующих команд:

1)     L80
2)     L80 "командная строка"

     В  режиме (1) после загрузки компоновщик выводит на  экран запрос 
* и ждет ввода командной строки.

     В режиме (2) командная строка может состоять из нескольких
подстрок.

     Командная строка L80 состоит из списка имен файлов, разделенных 
запятыми, и ключей компоновки. Все эти файлы должны быть загружены 
компоновщиком.Формат командной строки следующий:

	файл 1,файл 2,...,Файл N

     Тип всех файлов - REL.
     Перед любым именем файла можно задать имя диска, с которого будет 
загружаться этот файл. По умолчанию файл берется с текущего диска.

     После выполнения каждой командной подстроки компоновщик, закончив 
процесс загрузки, выводит список неопределенных символов 
(неудовлетворенных EXTRN), заканчивающийся *.  Кроме того, он выводит 
адрес начала и конца загруженного файла.

	Пример.

* MAIN
  DATA   0100  0200 Программа занимает область памяти 100H-200H
  SUBR1* 	    (SUBR1 не определено)
* SUBR1
  DATA   0100  0300 программа занимает область памяти 100H-300H
*

     Для удовлетворения внешних ссылок необходимо осуществить поиск в 
библиотеке подпрограмм или в библиотеке, созданной пользователем.

   5.3. Ключи компоновки

     При вводе командной строки можно также задавать различные ключи и 
с их помощью управлять процессом компоновки.  Ключи можно вводить:

     - как отдельные команды;
     - после имени файла;
     - в конце командной строки.

   Ключ                   производимое действие
   ----                   ---------------------

   /R          Сброс. Перевод L80 в начальное состояние.

   /E или      Завершение компоновки, выход из L80 и возврат в
   /E:"имя"    операционныю систему.  На активном диске в системной 
               библиотеке ищутся имена для удовлетворения всех 
               неопределенных ссылок.  До выхода в систему L80 
               печатает три числа:  стартовый адрес, адрес следующего 
               доступного байта и число использованных страниц (по 256
               байт).  Если задано "имя", то оно будет использоваться 
               как стартовый адрес. "Имя" должно быть определено в 
               одном из модулей.  /E используют для загрузки 
               скомпонованной программы в память и выхода в систему.

   /G или      Завершение компоновки и выполнение программы.  L80 
   /G:"Имя"    осуществляет те же действия, что и при ключе /E, но 
               вместо выхода в систему передает управление загруженной 
               программе. Перед запуском программы L80 печатается 
               сообщение:

			BEGIN EXECUTION

   /N          Если задано "имя файла" /N, то программа под заданным 
               именем будет записана на диск. Тип файла будет COM. 
               Этот ключ может быть задан только совместно с ключем /E 
               или /G.

   /P И /D     /P и /D позволяют установить счетчики адреса для 
               следующей загружаемой программы. /P и /D не влияют на 
               уже загруженные программы.

		Формат ключей:

                /P:<адрес> или /D:<адрес>

          где   <адрес> - это желаемое значение счетчика адреса в 
                текущей системе счисления (16-ричной по умолчанию; 
                ключ /O устанавливает 8-ричную систему счисления, а /H 
                - 16-ричную). По умолчанию L80 использует ключ /P:103, 
                оставляя 3 байта для JMP на начало программы.

          *) Примечание. Не следует использовать /P или /D для 
                загрузки программы, начиная с адреса 100, если только
                программа не начинает работать с этого адреса.  Если 
                ключ /D не задан, то область данных для каждого модуля 
                размещается перед областью программы.  Если задан ключ 
                /D, то области DATA и COMMON загружаются с заданного 
                адреса.

		Пример.

     */P:200        Разместить область команд с адреса 200

     */R            Сброс компоновки
     */P:200 /D:400 Разместить область команд с 200, а область данных 
                    с 400 по F00.


   /U          Вывести начало и конец программы и области данных, а 
               также все неопределенные EXTRN сразу после обработки 
               данной командной подстроки.  Информация о программе 
               печатается лишь тогда, когда задан ключ /D.

   /M          Вывести начало и конец программы и области данных, все 
               определенные EXTRN и их значения и все неопределенные 
               EXTRN.

   /S          Для удовлетворения неопределенных EXTRN осуществить 
               поиск в файле, заданном непосредственно перед ключом 
               /S.

   /X          Если задано: имя /N, то /X вызовет создание файла 
               "имя".HEX

	Примеры:

* EX,EX1,EXAM/N/E   Загрузить и скомпоновать модули EX.REL
			И EX1.REL. Создать из них файл EXAM.COM

* MYLIB/S,MYSUB,MYPOG/N,MYPROG/M/G
               Вести поиск EXTRN в файле MYLIB.REL.  Загрузить и 
               скомпоновать файлы MYSUB.REL И MYPROG.REL.  Создать 
               файл MYPROG.COM. Вывести список всех EXTRN. Выполнить 
               программу MYPROG.

     Нормальный выход из компоновщика производится по ключу /E или /G.


   5.4. Сообщения об ошибках

     В процессе работы L80 может выдать следующие сообщения об
ошибках:

? NO START ADDRESS
               Нет стартового адреса.  Был использован ключ /G, но 
               основная программа не загружена.

? LOADING ERROR
               Ошибка загрузки.  Последний заданный для компоновки 
               файл не был создан в правильном для L80 формате.

? OUT OF MEMORY
               Недостаточно памяти.  Для загрузки программы 
               недостаточно памяти

? COMMAND ERROR  
               Ошибка в команде.  L80 не может опознать команду.

? FILE NOT FOUND
               Файл не найден.  Среди файлов типа REL не найден 
               заданный файл.

% 2ND COMMON LARGER /XXXXXX/
               Второй COMMON больше.  Начальное задание блока COMMON 
               не задало COMMON максимального размера.  Следует 
               изменить порядок компоновки или изменить определение 
               COMMON.

% MULT.DEF.GLOBAL YYYYYY
               Многократное определение глобального имени.  Одно и то 
               же имя определено как ENTRY в нескольких модулях.

% OVERLAYING PROGRAM AREA, START=XXXX
	     DATA	 , PUBLIC="Символич.Имя"(XXXX)
			 , EXTERNAL="символич.Имя"(XXXX)
               Перекрытие программной области.  Ключи /P или /D 
               вызовут разрушение уже загруженных данных.

? INTERSECTING PROGRAM AREA
	       DATA
               Пересечение областей программы и данных.

? START SYMBUL-"Имя"-UNDEFINED
               Не определено имя начала программы.  После ключа /E: 
               или /G: символ, заданный в ключе, отсутствует в 
               программе.

ORIGIN ABOVE LOADER MEMORY< MOVE ANYWAY (J OR N)?
      [BELOW]
               Счетчик адреса за пределами памяти.  Загрузить ниже или 
               удалить?

                 6. Библиотекарь - LIB
                 ---------------------

   6.1. Назначение библиотекаря

     Программа библиотекарь предназначена для создания и корректировки 
библиотеки перемещаемых модулей. С помощью библиотекаря пользователь 
может создавать и свои собственные библиотеки.


   6.2. Обращение к библиотекарю

     Программа хранится на диске в файле LIB.COM.  Для  запуска
программы необходимо ввести команду:

		LIB

     По этой команде библиотекарь загружается в память и выводит 
запрос * . Это означает, что он готов к работе и ожидает ввода 
командной строки.  Командная строка состоит из имени файла-приемника 
(под этим именем на диске будет создана библиотека), знака равенства и 
перечня файлов-источников.  Командная строка указывает библиотекарю, 
какие модули пользователь желает включить в свою библиотеку.  Все 
исходные модули должны иметь тип REL, результатом работы будет файл с
заданным именем и типом REL.  Если имя файла-приемника не задано, то 
по умолчанию создается файл FORLIB.LIB.

     В качестве файла-источника может быть задана уже имеющаяся
библиотека. Тогда по желанию можно включить в файл-приемник всю
библиотеку целиком или выбрать из нее лишь некоторые модули.

     Командная строка может быть задана при вызове LIB.

	Пример.

	LIB MYLIB = ALFA,BETA,GAMMA


   6.3. Задание файлов-источников

     Файл-источник может быть задан несколькими способами:

     - файл состоит из одного модуля. Тогда просто задается имя
       файла;
     - файл  содержит несколько модулей.  В этом  случае  можно
       задать  только  имя  файла.  Тогда  файл  будет  включен
       целиком.  Можно  после  имени  файла в  угловых  скобках
       задать через запятую имена необходимых модулей. При этом
       будут включены только необходимые модули.

	Пример.

	BILIB <FIRST,MIDDLE,LAST>

     Если  нужно включить группу модулей,  то используются  две
точки (..).
     <.."Имя  модуля"> означает включение всех  модулей,стоящих
до заданного и заданный модуль.
     <"Имя модуля"..> Означает включение всех модулей,  начиная
с заданного.
     <"Имя модуля 1".."Имя модуля 2"> означает включение группы
стоящих подряд модулей,  начиная с "имя модуля 1" и кончая "имя
модуля 2".

     Можно также задать "имя модуля"+-N, где N не больше 255.
     <"Имя"+1> означает модуль, стоящий после заданного.
     <"Имя"-1> означает модуль, стоящий до заданнго.

	Пример.

	<SIN+1..COS-1> Включить все модули, начиная с модуля,
	идущего после модуля с именем SIN, и кончая модулем,
	стоящим до модуля COS.


   6.4. Ключи библиотекаря

     для управления созданием библиотеки используются ключи:

  /O   для ключа /L установить режим восьмеричного вывода;

  /H   для ключа /L установить режим шестнадцатиричного вывода;

  /U   вывести  список  символов,  оставшихся  неопределенными
       после поиска по всей библиотеке;

  /L    вывести список всех заданных модулей и  содержащихся  в
        них определений символических имен;

  /C   заново начать создание библиотеки;

  /E    выход  в операционную  систему.  Созданная  библиотека,
        имевшая  тип LIB,переименовывается и получает тип  REL.
        Старая библиотека с таким же именем стирается;

  /R    осуществляет  то  же,   что  и  /E,  но  без  выхода  в
        операционную систему.


	В н и м а н и е !
	-----------------
	/E легко может разрушить библиотеку FORLIB.REL. Если вы
        не хотите разрушить старую библиотеку, то для выхода из
	"библиотекаря"  используйте  ^C.   При  этом  на  диске
        остается файл "имя".LIB. Его следует стереть, используя
        команду ERA.

     *) Примечание.  В библиотеку сначала желательно помещать модули,
        содержащие внешние ссылки, а лишь потом модули, содержащие эти 
        имена как ENTRY. Это облегчит работу компоновщика, т.к. Иначе 
        он не сможет за один проход удовлетворить внешние ссылки.

   6.5. Сообщения, выдаваемые библиотекарем

     Если при задании командной строки для LIB был указан ключ /L, то 
библиотекарь выдает на консоль следующие сведения о каждом модуле, 
входящем в указанный библиотечный файл:

     MODULE "имя модуля" OF "имя файла"
     LENTH OF PROGRAM "число"	- длина области команд
     LENTH DATA AREA "число"	- длина области данных

     ENTRY POINT(S):		- точки входа
     				"список     глобальных    имен,
                                заданных  в данном  модуле  как
                                ENTRY, и их адреса"

     COMMON BLOCK(S):		- блоки COMMON
				"список имен COMMON"

     EXTERNAL REFERENCE(S):	- ссылки на внешние имена
				"список глобальных имен,которые
				в данном модуле определены как
				EXTRN"

     После сведения о каждом модуле на консоль выводится сводная 
таблица глобальных имен и модулей, в которых они определены как ENTRY.

SYMBOL VALUE DEFINED REFERENCED -
			Символ  значение  где определен
			"список глобальных имен"


     В процессе работы LIB может выдавать следующие сообщения
об ошибках:

     OUT OF MEMORY		памяти недостаточно

     COMMAND ERROR		неверная команда

     FILE READ ERROR		ошибка при чтении файла

     FILE NOT FOUND		файл не найден

     CAN'T ENTER FILE		с файлом работать нельзя

     MODULE NAME/NUMBER NOT FOUND IN FILE
            модуль с заданным именем/номером не найден в файле

     FIRST MODULE IN UNTIL CLAUSE AFTER LAST
	    первый модуль в списке идет после последнего

     LIBRARY WRITE ERROR	ошибка при записи в библиотеку

     UNSATISFIED EXTERNAL REQUEST(S)
				неудовлетворенный запрос EXTRN


                                        приложение 1

          Команды микропроцессора КР580ВМ80А
          ----------------------------------

                                             засылка
  пересылка            пересылка            константы
  ---------            ---------            ---------
40  MOV B,B          60  MOV H,B           06  MVI B,D8
41  MOV B,C          61  MOV H,C           0E  MVI C,D8
42  MOV B,D          62  MOV H,D           16  MVI D,D8
43  MOV B,E          63  MOV H,E           1E  MVI E,D8
44  MOV B,H          64  MOV H,H           26  MVI H,D8
45  MOV B,L          65  MOV H,L           2E  MVI L,D8
46  MOV B,M          66  MOV H,M           36  MVI M,D8
47  MOV B,A          67  MOV H,A           3E  MVI A,D8

48  MOV C,B          68  MOV L,B           01  LXI B, D16
49  MOV C,C          69  MOV L,C           11  LXI D, D16
4A  MOV C,D          6A  MOV L,D           21  LXI H, D16
4B  MOV C,E          6B  MOV L,E           31  LXI SP,D16
4C  MOV C,H          6C  MOV L,H
4D  MOV C,L          6D  MOV L,L              чтение
4E  MOV C,M          6E  MOV L,M             --------
4F  MOV C,A          6F  MOV L,A           0A  LDAX B
                                           1A  LDAX D
50  MOV D,B          70  MOV M,B           2A  LHLD ADR
51  MOV D,C          71  MOV M,C           3A  LDA  ADR
52  MOV D,D          72  MOV M,D
53  MOV D,E          73  MOV M,E              запись
54  MOV D,H          74  MOV M,H             --------
55  MOV D,L          75  MOV M,L           02  STAX B
56  MOV D,M                                12  STAX D
57  MOV D,A          77  MOV M,A           22  SHLD ADR
                                           32  STA  ADR
58  MOV E,B          78  MOV A,B
59  MOV E,C          79  MOV A,C           специальные
5A  MOV E,D          7A  MOV A,D             команды
5B  MOV E,E          7B  MOV A,E           -----------
5C  MOV E,H          7C  MOV A,H           00  NOP
5D  MOV E,L          7D  MOV A,L           76  HLT
5E  MOV E,M          7E  MOV A,M           F3  DI
5F  MOV E,A          7F  MOV A,A           FB  EI

операции                                   16-разрядное
со стеком            ввод-вывод              сложение
-----------          ----------            ------------
C5  PUSH B           D3  OUT D8            09  DAD B
D5  PUSH D           DB  IN  D8            19  DAD D
E5  PUSH H                                 29  DAD H
F5  PUSH PSW                               39  DAD SP

C1  POP B            команды                прочие
D1  POP D            сдвига                операции
E1  POP H            -------               --------
F1  POP PSW          07  RLC               EB  XCHG
                     0F  RRC               27  DAA
E3  XTHL             17  RAL               2F  CMA
F9  SPHL             1F  RAR               37  STC
                                           3F  CMC

арифметические       логические
  операции            операции             инкремент
--------------       ----------            ---------
80  ADD B            A0  ANA B             04  INR B
81  ADD C            A1  ANA C             0C  INR C
82  ADD D            A2  ANA D             14  INR D
83  ADD E            A3  ANA E             1C  INR E
84  ADD H            A4  ANA H             24  INR H
85  ADD L            A5  ANA L             2C  INR L
86  ADD M            A6  ANA M             34  INR M
87  ADD A            A7  ANA A             3C  INR A

88  ADC B            A8  XRA B             03  INX B
89  ADC C            A9  XRA C             13  INX D
8A  ADC D            AA  XRA D             23  INX H
8B  ADC E            AB  XRA E             33  INX SP
8C  ADC H            AC  XRA H
8D  ADC L            AD  XRA L             декремент
8E  ADC M            AE  XRA M             ---------
8F  ADC A            AF  XRA A             05  DCR B
                                           0D  DCR C
90  SUB B            B0  ORA B             15  DCR D
91  SUB C            B1  ORA C             1D  DCR E
92  SUB D            B2  ORA D             25  DCR H
93  SUB E            B3  ORA E             2D  DCR L
94  SUB H            B4  ORA H             35  DCR M
95  SUB L            B5  ORA L             3D  DCR A
96  SUB M            B6  ORA M
97  SUB A            B7  ORA A             0B  DCX B
                                           1B  DCX D
98  SBB B            B8  CMP B             2B  DCX H
99  SBB C            B9  CMP C             3B  DCX SP
9A  SBB D            BA  CMP D
9B  SBB E            BB  CMP E             спец.Вызов
9C  SBB H            BC  CMP H             ----------
9D  SBB L            BD  CMP L             C7  RST 0
9E  SBB M            BE  CMP M             CF  RST 1
9F  SBB A            BF  CMP A             D7  RST 2
                                           DF  RST 3
C6  ADI,D8           E6  ANI,D8            E7  RST 4
CE  ACI,D8           EE  XRI,D8            EF  RST 5
D6  SUI,D8           F6  ORI,D8            F7  RST 6
DE  SBI,D8           FE  CPI,D8            FF  RST 7

переход                вызов                возврат
-------              ---------             ---------
C3  JMP  ADR         CD  CALL  ADR         C9  RET
C2  JNZ  ADR         C4  CNZ   ADR         C0  RNZ
CA  JZ   ADR         CC  CZ    ADR         C8  RZ
D2  JNC  ADR         D4  CNC   ADR         D0  RNC
DA  JC   ADR         DC  CC    ADR         D8  RC
E2  JPO  ADR         E4  CPO   ADR         E0  RPO
EA  JPE  ADR         EC  CPE   ADR         E8  RPE
F2  JP   ADR         F4  CP    ADR         F0  RP
FA  JM   ADR         FC  CM    ADR         F8  RM
E9  PCHL


примечание: D8-однобайтовый операнд, D16-двухбайтовый операнд,
            ADR-двухбайтовый операнд (адрес), м-ячейка памяти,
            A,B,C,D,E,H,L,SP,PSW - регистры микропроцессора.
                                        Приложение 2

          коды команд микропроцессора КР580ВМ80А
          --------------------------------------

00  NOP                 30  -----             60  MOV H,B
01  LXI B,D16           31  LXI SP,D16        61  MOV H,C
02  STAX B              32  STA ADR           62  MOV H,D
03  INX B               33  INX SP            63  MOV H,E
04  INR B               34  INR M             64  MOV H,H
05  DCR B               35  DCR M             65  MOV H,L
06  MVI B,D8            36  MVI M,D8          66  MOV H,M
07  RLC                 37  STC               67  MOV H,A
08  -----               38  -----             68  MOV L,B
09  DAD B               39  DAD SP            69  MOV L,C
0A  LDAX B              3A  LDA ADR           6A  MOV L,D
0B  DCX B               3B  DCX SP            6B  MOV L,E
0C  INR C               3C  INR A             6C  MOV L,H
0D  DCR C               3D  DCR A             6D  MOV L,L
0E  MVI C,D8            3E  MVI A,D8          6E  MOV L,M
0F  RRC                 3F  CMC               6F  MOV L,A



10  -----               40  MOV B,B           70  MOV M,B
11  LXI D,D16           41  MOV B,C           71  MOV M,C
12  STAX D              42  MOV B,D           72  MOV M,D
13  INX D               43  MOV B,E           73  MOV M,E
14  INR D               44  MOV B,H           74  MOV M,H
15  DCR D               45  MOV B,L           75  MOV M,L
16  MVI D,D8            46  MOV B,M           76  HLT
17  RAL                 47  MOV B,A           77  MOV M,A
18  -----               48  MOV C,B           78  MOV A,B
19  DAD D               49  MOV C,C           79  MOV A,C
1A  LDAX D              4A  MOV C,D           7A  MOV A,D
1B  DCX D               4B  MOV C,E           7B  MOV A,E
1C  INR E               4C  MOV C,H           7C  MOV A,H
1D  DCR E               4D  MOV C,L           7D  MOV A,L
1E  MVI E,D8            4E  MOV C,M           7E  MOV A,M
1F  RAR                 4F  MOV C,A           7F  MOV A,A



20  -----               50  MOV D,B           80  ADD B
21  LXI H,D16           51  MOV D,C           81  ADD C
22  SHLD ADR            52  MOV D,D           82  ADD D
23  INX H               53  MOV D,E           83  ADD E
24  INR H               54  MOV D,H           84  ADD H
25  DCR H               55  MOV D,L           85  ADD L
26  MVI H,D8            56  MOV D,M           86  ADD M
27  DAA                 57  MOV D,A           87  ADD A
28  -----               58  MOV E,B           88  ADC B
29  DAD H               59  MOV E,C           89  ADC C
2A  LHLD ADR            5A  MOV E,D           8A  ADC D
2B  DCX H               5B  MOV E,E           8B  ADC E
2C  INR L               5C  MOV E,H           8C  ADC H
2D  DCR L               5D  MOV E,L           8D  ADC L
2E  MVI L,D8            5E  MOV E,M           8E  ADC M
2F  CMA                 5F  MOV E,A           8F  ADC A


90  SUB B               C0  RNZ               F0  RP
91  SUB C               C1  POP B             F1  POP PSW
92  SUB D               C2  JNZ ADR           F2  JP ADR
93  SUB E               C3  JMP ADR           F3  DI
94  SUB H               C4  CNZ ADR           F4  CP ADR
95  SUB L               C5  PUSH B            F5  PUSH PSW
96  SUB M               C6  ADI D8            F6  ORI D8
97  SUB A               C7  RST 0             F7  RST 6
98  SBB B               C8  RZ                F8  RM
99  SBB C               C9  RET               F9  SPHL
9A  SBB D               CA  JZ ADR            FA  JM ADR
9B  SBB E               CB  -----             FB  EI
9C  SBB H               CC  CZ ADR            FC  CM ADR
9D  SBB L               CD  CALL ADR          FD  -----
9E  SBB M               CE  ACI D8            FE  CPI D8
9F  SBB A               CF  RST 1             FF  RST 7


A0  ANA B               D0  RNC
A1  ANA C               D1  POP D
A2  ANA D               D2  JNC ADR
A3  ANA E               D3  OUT D8
A4  ANA H               D4  CNC ADR
A5  ANA L               D5  PUSH D
A6  ANA M               D6  SUI D8
A7  ANA A               D7  RST 2
A8  XRA B               D8  RC
A9  XRA C               D9  -----
AA  XRA D               DA  JC ADR
AB  XRA E               DB  IN D8
AC  XRA H               DC  CC ADR
AD  XRA L               DD  -----
AE  XRA M               DE  SBI D8
AF  XRA A               DF  RST 3


B0  ORA B               E0  RPO
B1  ORA C               E1  POP H
B2  ORA D               E2  JPO ADR
B3  ORA E               E3  XTHL
B4  ORA H               E4  CPO ADR
B5  ORA L               E5  PUSH H
B6  ORA M               E6  ANI D8
B7  ORA A               E7  RST 4
B8  CMP B               E8  RPE
B9  CMP C               E9  PCHL
BA  CMP D               EA  JPE ADR
BB  CMP E               EB  XCHG
BC  CMP H               EC  CPE ADR
BD  CMP L               ED  -----
BE  CMP M               EE  XRI D8
BF  CMP A               EF  RST 5





примечание: D8-однобайтовый операнд, D16-двухбайтовый операнд,
            ADR-двухбайтовый операнд (адрес), м-ячейка памяти,
            A,B,C,D,E,H,L,SP,PSW - регистры микропроцессора.

                                             Приложение 3

               описание команд мп КР580ВМ80А

+------------+---------------------+--------------------------+
! мнемоника  !      операция       !        коментарий        !
+------------+---------------------+--------------------------+
!            !                     ! содержимое байта (D8) за-!
! MVI R,D8   !      R <--- D8      ! писывается в регистр (R) !
!            !                     ! или в ячейку памяти (M). !
! MVI M,D8   !  M(HL) <--- D8      ! Адрес ячейки памяти ука- !
!            !                     ! вается парой регистров HL!
!            !  R=A,B,C,D,E,H,L    ! признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! загрузить 16-разрядный   !
! LXI YZ,D16 !     YZ <--- D16     ! операнд в пару регистров !
!            !                     ! YZ (BC,DE,HL,SP).        !
!            ! YZ=B(C),D(E),H(L),SP! Признаки не изменяются   !
+------------+---------------------+--------------------------+
! MOV R,R1   !      R <--- R1      ! обмен содержимого  ре-   !
! MOV M,R    !      R ---> M(HL)   ! гистров и ячеек памяти.  !
! MOV R,M    !      R <--- M(HL)   !                          !
!            ! R,R1=A,B,C,D,E,H,L  ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! содержимое ячейки памяти,!
!            !                     ! адресованной в параметре !
! LDA ADR    !      A <--- M(ADR)  ! (ADR),перемещается в ак- !
!            !                     ! кумулятор.               !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! содержимое ячейки памяти,!
! LDAX B     !      A <--- M(BC)   ! адресованной парой регис-!
!            !                     ! тров (BC) или (DE),пере- !
! LDAX D     !      A <--- M(DE)   ! мещается в аккумулятор.  !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! содержимое двух смежных  !
!            !   L <--- M(ADR)     ! ячеек памяти,адресованных!
! LHLD ADR   !                     ! в параметре (ADR),переме-!
!            !   H <--- M(ADR+1)   ! щается в пару регистров  !
!            !                     ! (HL).                    !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! содержимое аккумулятора  !
!            !                     ! перемещается в ячейку па-!
! STA ADR    !      A ---> M(ADR)  ! мяти,адресованную в па-  !
!            !                     ! раметре (ADR).           !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! содержимое аккумулятора  !
! STAX B     !      A ---> M(BC)   ! перемещается в ячейку па-!
!            !                     ! мяти,адресованную в паре !
! STAX D     !      A ---> M(DE)   ! регистров (BC) или (DE). !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! содержимое пары регистров!
!            !    L ---> M(ADR)    ! (HL),перемещается в смеж-!
! SHLD ADR   !                     ! ные ячейки памяти,адресо-!
!            !    H ---> M(ADR+1)  ! ванные в параметре (ADR).!
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
+------------+---------------------+--------------------------+
! мнемоника  !      операция       !        коментарий        !
+------------+---------------------+--------------------------+
!            !                     ! обменять содержимое пар  !
!  XCHG      !    HL <---> DE      ! регистров (HL) и (DE).   !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! переслать в указатель    !
!  SPHL      !     HL ---> SP      ! стека содержимое пары    !
!            !                     ! регистров (HL).          !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! обменять содержимое стека!
!  XTHL      !    L <---> M(SP)    ! и пары регистров (HL).   !
!            !    H <---> M(SP+1)  ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !    YZ ---> M(SP-1), ! переслать в стек содержи-!
!            !    YZ ---> M(SP-2), ! мое пары регистров (YZ)  !
! PUSH YZ    !   (SP-2) ---> SP    ! и уменьшить содержимое   !
!            !                     ! указателя стека на 2.    !
!            !YZ=B(C),D(E),H(L),PSW! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! переслать содержимое сте-!
!            !     M(SP) ---> YZ   ! ка в пару регистров (YZ) !
!            !   M(SP+1) ---> YZ   ! и увеличить содержимое   !
!  POP YZ    !    (SP+2) ---> SP   ! указателя стека на 2.    !
!            !                     ! По команде POP PSW изме- !
!            !YZ=B(C),D(E),H(L),PSW! няются все признаки.     !
+------------+---------------------+--------------------------+
!            !                     ! Переход по адресу задан- !
!  PCHL      !    HL ---> PC       ! ному содержимым пары ре- !
!            !                     ! гистров (HL).            !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !   D8(N) ---> A      ! ввод байта из порта (N)  !
!  IN N      !                     ! в аккумулятор.           !
!            !    N = 00...FF      ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !   A ---> D8(N)      ! вывод содержимого аккуму-!
!  OUT N     !                     ! лятора в порт (N).       !
!            !    N = 00...FF      ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!  NOP       !   нет операции      ! холостая операция        !
+------------+---------------------+--------------------------+
!            !                     ! остановить выполнение    !
!            !                     ! программы до тех пор,пока!
!  HLT       !  останов            ! не будет активизировано  !
!            !                     ! прерывание или "сброс".  !
+------------+---------------------+--------------------------+
!  EI        !      INTE=1         ! Разрешить прерывание     !
+------------+---------------------+--------------------------+
!  DI        !      INTE=0         ! запретить прерывание     !
+----------------+-----------------+--------------------------+
! команда  адрес ! команда  адрес  !                          !
+----------------+-----------------+ перейти к подпрограмме   !
!  RST 0   0000  !  RST 4   0020   !                          !
!  RST 1   0008  !  RST 5   0028   ! обслуживания прерывания  !
!  RST 2   0010  !  RST 6   0030   !                          !
!  RST 3   0018  !  RST 7   0038   !                          !
+----------------+-----------------+--------------------------+

+------------+---------------------+--------------------------+
! мнемоника  !      операция       !        коментарий        !
+------------+---------------------+--------------------------+
!  ADD R     !     A+R ---> A      ! сложить содержимое ре-   !
!            !                     ! гистра или ячейки памяти !
!  ADD M     ! A+M(HL) ---> A      ! с аккумулятором.         !
!            !                     ! Воздейств.На все признаки!
+------------+---------------------+--------------------------+
!            !                     ! сложить содержимое ре-   !
!  ADC R     ! A+R+CARRY ---> A    ! гистра или ячейки памяти !
!            !                     ! с содержимым триггера пе-!
!  ADC M     ! A+M(HL)+CARRY --> A ! реноса и аккумулятором.  !
!            !                     ! Воздейств.На все признаки!
+------------+---------------------+--------------------------+
!            !                     ! из содержимого аккумуля- !
!  SUB R     !     A-R ---> A      ! тора вычитается содержи- !
!            !                     ! мое регистра или ячейки  !
!  SUB M     ! A-M(HL) ---> A      ! памяти.                  !
!            !                     ! Воздейств.На все признаки!
+------------+---------------------+--------------------------+
!            !                     ! из содержимого аккумуля- !
!  SBB R     ! A-R-CARRY ---> A    ! тора вычитается содержи- !
!            !                     ! мое регистра или ячейки  !
!  SBB M     ! A-M(HL)-CARRY --> A ! памяти и содержимое триг-!
!            !                     ! гера переноса.           !
!            !                     ! Воздейств.На все признаки!
+------------+---------------------+--------------------------+
!            !    X1   X2   Y      ! операция "и" над содержи-!
!  ANA R     !   -------------     ! мым регистра или ячейки  !
!            !    1    1    1      ! памяти и аккумулятором   !
!  ANA M     !    0    1    0      ! (поразрядно).            !
!            !    1    0    0      ! Воздействует на S,Z,P.   !
!            !    0    0    0      ! CARRY ---> 0             !
+------------+---------------------+--------------------------+
!            !    X1   X2   Y      ! Операция "исключающ.Или" !
!  XRA R     !   -------------     ! над содержимым регистра  !
!            !    1    1    0      ! или ячейки памяти и акку-!
!  XRA M     !    0    1    1      ! мулятором (поразрядно).  !
!            !    1    0    1      ! Воздействует на S,Z,P.   !
!            !    0    0    0      ! CARRY ---> 0             !
+------------+---------------------+--------------------------+
!            !    X1   X2   Y      ! Операция "или" над содер-!
!  ORA R     !   -------------     ! жимым регистра или ячей- !
!            !    1    1    1      ! ки памяти и аккумулятором!
!  ORA M     !    0    1    1      ! (поразрядно).            !
!            !    1    0    1      ! Воздействует на S,Z,P.   !
!            !    0    0    0      ! CARRY ---> 0             !
+------------+---------------------+--------------------------+
!            !            _        ! Инверсия аккумулятора    !
!   CMA      !     A ---> A        ! признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! установить триггер пере- !
!   STC      !   CARRY ---> 1      ! носа в "1"               !
!            !                     ! остальные призн.Не измен.!
+------------+---------------------+--------------------------+
!            !              _____  ! Инверсия триггера перено-!
!   CMC      !   CARRY ---> CARRY  ! са.                      !
!            !                     ! Остальные призн.Не измен.!
+------------+---------------------+--------------------------+


+------------+---------------------+--------------------------+
! Мнемоника  !      операция       !        коментарий        !
+------------+---------------------+--------------------------+
!            !                     ! сложить содержимое акку- !
! ADI D8     !    A+D8 ---> A      ! мулятора и байта  (D8).  !
!            !                     ! Воздейств.На все признаки!
+------------+---------------------+--------------------------+
!            !                     ! сложить содержимое акку- !
!            !                     ! мулятора и байта (D8) с  !
!  ACI D8    !  A+D8+CARRY ---> A  ! учетом переноса.         !
!            !                     ! Воздейств.На все признаки!
+------------+---------------------+--------------------------+
!            !                     ! вычесть из содержимого   !
!            !                     ! аккумулятора,содержимое  !
!  SUI D8    !     A-D8 ---> A     ! байта (D8).              !
!            !                     ! Воздейств.На все признаки!
+------------+---------------------+--------------------------+
!            !                     ! вычесть из содержимого   !
!            !                     ! аккумулятора,содержимое  !
!  SBI D8    !  A-D8-CARRY ---> A  ! байта (D8) с учетом пере-!
!            !                     ! носа.                    !
!            !                     ! Воздейств.На все признаки!
+------------+---------------------+--------------------------+
!            !   X1   X2   Y       ! операция "и" с содержимым!
!            !  -------------      ! аккумулятора и байта (D8)!
!  ANI D8    !   1    1    1       !                          !
!            !   0    1    0       ! воздействует на S,Z,P.   !
!            !   1    0    0       ! CARRY ---> 0             !
!            !   0    0    0       !                          !
+------------+---------------------+--------------------------+
!            !   X1   X2   Y       ! Операция "исключ. Или"   !
!            !  -------------      ! с содержимым аккумулятора!
!            !   1    1    0       ! и байта (D8).            !
!  XRI D8    !   0    1    1       !                          !
!            !   1    0    1       ! Воздействует на S,Z,P.   !
!            !   0    0    0       ! CARRY ---> 0             !
+------------+---------------------+--------------------------+
!            !   X1   X2   Y       ! Операция "или" с содер-  !
!            !  -------------      ! жимым аккумулятора и     !
!            !   1    1    1       ! байта (D8).              !
!  ORI D8    !   0    1    1       !                          !
!            !   1    0    1       ! Воздействует на S,Z,P.   !
!            !   0    0    0       ! CARRY ---> 0             !
+------------+---------------------+--------------------------+
!            !                     ! Сравнить содержимое акку-!
!            !                     ! мулятора и содержимое ре-!
!  CMP R     !    A-R ---> A       ! гистра или ячейки памяти,!
!            !                     ! установить признаки.     !
!  CMP M     !  A-M(HL) ---> A     ! A = R ---> Z=1           !
!            !                     ! A < R ---> CARRY=1       !
!            !                     ! A >= R --> CARRY=0       !
+------------+---------------------+--------------------------+
!            !                     ! Сравнить содержимое акку-!
!            !                     ! мулятора и содержимое    !
!            !                     ! байта (D8),установить    !
!  CPI D8    !    A-R ---> A       ! признаки.                !
!            !                     ! A = R ---> Z=1           !
!            !                     ! A < R ---> CARRY=1       !
!            !                     ! A >= R --> CARRY=0       !
+------------+---------------------+--------------------------+

+------------+---------------------+--------------------------+
! Мнемоника  !      операция       !        коментарий        !
+------------+---------------------+--------------------------+
!            !                     ! увеличить на 1 содержимое!
!  INR R     !     R+1 ---> R      ! регистра или ячейки памя-!
!            !                     ! ти.                      !
!  INR M     ! M(HL)+1 ---> M(HL)  ! Воздействует на S,Z,AC,P.!
+------------+---------------------+--------------------------+
!            !                     ! Увеличить на 1 содержимое!
!  INX YZ    !    YZ+1 ---> YZ     ! пары регистров (YZ)      !
!            !                     ! признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! уменьшить на 1 содержимое!
!  DCR R     !     R-1 ---> R      ! регистра или ячейки памя-!
!            !                     ! ти.                      !
!  DCR M     ! M(HL)-1 ---> M(HL)  ! Воздействует на S,Z,AC,P.!
+------------+---------------------+--------------------------+
!            !                     ! Уменьшить на 1 содержимое!
!  DCX YZ    !    YZ-1 ---> YZ     ! пары регистров (YZ).     !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! сложить содержимое пары  !
!  DAD YZ    !   YZ+HL ---> HL     ! регистров (YZ) с содержи-!
!            !                     ! пары регистров (HL).     !
!            !                     ! Воздействует на CARRY    !
+------------+---------------------+--------------------------+
!            !                     ! десятичная коррекция со- !
!   DAA      !                     ! держимого аккумулятора   !
!            !                     ! воздейств.На все признаки!
+------------+---------------------+--------------------------+
!            ! CARRY <--- 7 ,      ! циклический сдвиг содер- !
!            ! 7 <-- 6 , 6 <-- 5 , ! жимого аккумулятора влево!
!   RLC      ! 5 <-- 4 , 4 <-- 3 , !                          !
!            ! 3 <-- 2 , 2 <-- 1 , !                          !
!            ! 1 <-- 0 , 0 <-- 7 . ! Воздействует на CARRY    !
+------------+---------------------+--------------------------+
!            ! 0 ---> CARRY ,      ! циклический сдвиг содер- !
!            ! 0 --> 7 , 7 --> 6 , ! жимого аккумулятора      !
!   RRC      ! 6 --> 5 , 5 --> 4 , ! вправо.                  !
!            ! 4 --> 3 , 3 --> 2 , !                          !
!            ! 2 --> 1 , 1 --> 0 , ! Воздействует на CARRY    !
+------------+---------------------+--------------------------+
!            ! CARRY <--- 7 ,      ! циклический сдвиг содер- !
!            ! 7 <-- 6 , 6 <-- 5 , ! жимого аккумулятора влево!
!   RAL      ! 5 <-- 4 , 4 <-- 3 , ! с использованием триггера!
!            ! 3 <-- 2 , 2 <-- 1 , ! переноса.                !
!            ! 1 <-- 0 , 0 <--CARRY! Воздействует на  CARRY   !
+------------+---------------------+--------------------------+
!            ! CARRY ---> 7 ,      ! циклический сдвиг содер- !
!            ! 7 --> 6 , 6 --> 5 , ! жимого аккумулятора      !
!   RAR      ! 5 --> 4 , 4 --> 3 , ! вправо с использованием  !
!            ! 3 --> 2 , 2 --> 1 , ! триггера переноса.       !
!            ! 1 --> 0 , 0 -->CARRY! Воздействует на CARRY    !
+------------+---------------------+--------------------------+
! мнемоника  !      операция       !        коментарий        !
+------------+---------------------+--------------------------+
!            !                     ! безусловный переход по   !
!  JMP ADR   !   ADR ---> PC       ! адресу (ADR).            !
!            !                     ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !                     ! безусловный переход к    !
!            !   PC ---> M(SP-1),  ! подпрограмме по адресу   !
!  CALL ADR  !   PC ---> M(SP-2),  ! (ADR) и сохранение в сте-!
!            ! SP-2 ---> SP,       ! ке адреса возврата.      !
!            !  ADR ---> PC.       ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!            !     M(SP) ---> PC,  ! выход из подпрограммы по !
!   RET      !   M(SP+1) ---> PC,  ! адресу возврата.         !
!            !      SP+2 ---> SP   ! Признаки не изменяются   !
+------------+---------------------+--------------------------+
!                  команды по условию                         !
+---------+--------------+--------------+---------------------+
! переход !   переход к  !  возврат из  !     коментарий      !
!         ! подпрограмме ! подпрограммы !                     !
+---------+--------------+--------------+---------------------+
! JNZ ADR !   CNZ ADR    !     RNZ      ! Z=0, результат не 0 !
+---------+--------------+--------------+---------------------+
! JZ  ADR !   CZ  ADR    !     RZ       ! Z=1, результат = 0  !
+---------+--------------+--------------+---------------------+
! JNC ADR !   CNC ADR    !     RNC      ! C=0, нет переноса   !
+---------+--------------+--------------+---------------------+
! JC  ADR !   CC  ADR    !     RC       ! C=1, есть перенос   !
+---------+--------------+--------------+---------------------+
! JPO ADR !   CPO ADR    !     RPO      ! P=0, нечетный рез.  !
+---------+--------------+--------------+---------------------+
! JPE ADR !   CPE ADR    !     RPE      ! P=1, Четный результ.!
+---------+--------------+--------------+---------------------+
! JP  ADR !   CP  ADR    !     RP       ! S=0, Положит.Рез.   !
+---------+--------------+--------------+---------------------+
! JM  ADR !   CM  ADR    !     RM       ! S=1, Отрицат.Рез.   !
+---------+--------------+--------------+---------------------+

                Условные обозначения
                --------------------
D8    - однобайтовый операнд ;
D16   - двухбайтовый операнд ;
ADR   - двухбайтовый операнд (адрес) ;
R     - регистр A,B,C,D,E,H,L
YZ    - пара регистров BC,DE,HL,SP,PSW ;
M     - ячейка памяти ;
M(HL) - ячейка памяти (адрес указан в паре регистров HL) ;
(N)   - содержимое порта ввода/вывода с номером (N=00...FF) .


                   Формат регистра признаков
                   -------------------------
      7     6     5      4     3     2     1     0
   +-----+-----+-----+------+-----+-----+-----+-----+
   !  S  !  Z  !  0  !  AC  !  0  !  P  !  1  !  C  !
   +-----+-----+-----+------+-----+-----+-----+-----+

S-SIGN (признак знака), Z-ZERO (признак нулевого результата),
AC-AUX CARRY (признак вспомогательного переноса),
P-PARITY (признак четности), C-CARRY (признак переноса).

Приложение 4
               пример программы копирования файлов
программа  копирования файлов представляет собой относительно
простой пример операций с файлом.
Исходный  текст  программы находится  в  файле COPY.MAC.  Для
создания файла COPY.COM Необходимо выполнить следующие операции:

A>M80 =COPY/L            <--- создаются файлы COPY.REL И COPY.PRN


A>L80 COPY,COPY/N/E      <--- Содается файл COPY.COM

     Ниже приведен листинг программы COPY.

	     ;
             ; Программа копирования файла  COPY
             ;
0000                         ASEG
                             ORG 0100H
0000         BOOT    EQU 0000H       ; перезагрузка системы
0005         BDOS    EQU 0005H       ; точка входа в BDOS
005C         FCBL    EQU 005CH       ; первое имя файла
005C         SFCB    EQU FCBL        ; FCB входного файла
006C         FCB2    EQU 006CH       ; второе имя файла
0080         DBUFF   EQU 0080H       ; буфер открываемый по умолчанию
0100         TPA     EQU 0100H       ; начало области TPA
             ;
0009         PRINTF  EQU 9           ; номер функции печати буфера
000F         OPENF   EQU 15          ; номер функции отрытия файла
0010         CLOSEF  EQU 16          ; номер функции закрытия файла
0013         DELETEF EQU 19          ; номер функции удаления файла
0014         READF   EQU 20          ; последовательное чтение
0015         WRITEF  EQU 21          ; последовательная запись
0016         MAKEF   EQU 22          ; номер функции создания файла
             ;
             ;
             ;
0100 310265          LXI SP,STACK    ; локальный стек
             ;
             ; перенос второго имени файла в DFCB
             ;
0103 0E10            MVI C,16        ; запись в половину FCB
0105 11006C          LXI D,FCB2      ; загрузка исходного байта
0108 210224          LXI H,DFCB      ; выходной FCB
010B 1A      MFCB:   LDAX D          ; входной FCB
010C 13              INX D           ; подготовка следующего
010D 77              MOV M,A         ; выходной FCB
010E 23              INX H           ; подготовка следующего
010F 0D              DCR C           ; счетчик от 16 ... 0
0110 C2010B          JNZ MFCB        ; Повторение цикла 16 раз
             ;
             ; имя было стерто, обнулить CR
             ;
0113 AF              XRA A           ; A=00H
0114 320244          STA DFCBCR      ; текущая запись=0
             ;
             ; входной и выходной FCB готовы
             ;
0117 11005C          LXI D,SFCB      ; входной файл
011A CD0169          CALL OPEN       ; 255, если ошибка
011D 110187          LXI D,NOFILE    ; сообщение о готовности
0120 3C              INR A           ; 255 заменяется на 0
0121 CC0161          CZ FINIS        ; если нет файла,то конец
             ;
             ; входной файл открыт, подготовка выходного
             ;
0124 110224          LXI D,DFCB      ; выходной FCB
0127 CD0173          CALL DELETE     ; стереть имеющиеся файлы
             ;
012A 110224          LXI D,DFCB      ; выходной FCB
012D CD0182          CALL MAKE       ; создать файл
0130 1101C1          LXI D,NODIR     ; сообщение о готовности
0133 3C              INR A           ; заменить 255 на 0
0134 CC0161          CZ FINIS        ; если каталог переполнен,то конец
             ;
             ; входной файл открыт, выходной файл открыт,
             ; копирование до конца входного файла
             ;
0137 11005C  COPY:   LXI D,SFCB      ; загрузка входного
013A CD0178          CALL READ       ; чтение следующей записи
013D B7              ORA A           ; конец файла ?
013E C20151          JNZ EOFILE      ; если да, то пропустить запись в
                                     ; выходной файл
             ;
             ; не конец файла, пишем запись
             ;
0141 110224          LXI D,DFCB      ; загрузка выходного FCB
0144 CD017D          CALL WRITE      ; пишем запись
0147 1101DA          LXI D,SPACE     ; сообщение о готовности
014A B7              ORA A           ; если все в порядке, то 00
014B C40161          CNZ FINIS       ; иначе конец
014E C30137          JMP COPY        ; повторение цикла до конца файла
             ;
0151         EOFILE:                 ; конец файла, закрываем выходной
                                     ; файл
0151 110224          LXI D,DFCB      ; загружаем выходной FCB
0154 CD016E          CALL CLOSE      ; если ошибка, то код 255
0157 2101F3          LXI H,WRPROT    ; сообщение о готовности
015A 3C              INR A           ; заменить 255 на 0
015B CC0161          CZ FINIS        ; иначе конец
             ;
             ; завершение копирования, конец файла
             ;
015E 11020A          LXI D,NORMAL    ; сообщение о готовности
             ;
             ;
0161         FINIS:                  ; выдача сообщения из DE,
                                     ; перезагрузка системы
0161 0E09            MVI C,PRINTF    ;
0163 CD0005          CALL BDOS       ; выдача сообщения
0166 C30000          JMP BOOT        ; перезагрузка
             ;
             ; подпрограммы взаимодействия с системой
             ; (все возвраты прямо из BDOS)
             ;
0169 0E0F    OPEN:   MVI C,OPENF
016B C30005          JMP BDOS
016E 0E10    CLOSE:  MVI C,CLOSEF
0170 C30005          JMP BDOS
0173 0E13    DELETE: MVI C,DELETEF
0175 C30005          JMP BDOS
0178 0E14    READ:   MVI C,READF
017A C30005          JMP BDOS
017D 0E15    WRITE:  MVI C,WRITEF
017F C30005          JMP BDOS
0182 0E16    MAKE:   MVI C,MAKEF
0184 C30005          JMP BDOS
             ;
             ; сообщение на консоль
             ;
0187 0D0A6E65 NOFILE: DB 0DH,0AH,'нет файла.   '
018B 74206661
018F 6A6C612E
0193 202020
0196 666F726D         DB 'Формат: COPY A:<имя файла> B:<имя файла>'
019A 61743A20
019E 434F5059
01A2 20413A3C
01A6 696D7120
01AA 66616A6C
01AE 613E2042
01B2 3A3C696D
01B6 71206661
01BA 6A6C613E
01BE 0D0A24           DB 0DH,0AH,'$'
01C1 0D0A6E65 NODIR:  DB 0DH,0AH,'нет места в каталоге',0DH,0AH,'$'
01C5 74206D65
01C9 73746120
01CD 77206B61
01D1 74616C6F
01D5 67650D0A
01D9 24
01DA 0D0A6E65 SPACE:  DB 0DH,0AH,'нет места для данных',0DH,0AH,'$'
01DE 74206D65
01E2 73746120
01E6 646C7120
01EA 64616E6E
01EE 79680D0A
01F2 24
01F3 0D0A7A61 WRPROT: DB 0DH,0AH,'защищено от записи',0DH,0AH,'$'
01F7 7D697D65
01FB 6E6F206F
01FF 74207A61
0203 70697369
0207 0D0A24
020A 0D0A6B6F NORMAL: DB 0DH,0AH,'копирование завершено',0DH,0AH,'$'
020E 7069726F
0212 77616E69
0216 65207A61
021A 7765727B
021E 656E6F0D
0222 0A24
             ;
             ; раздел данных
             ;
0224         DFCB:   DS 33           ; выходной FCB
0244         DFCBCR  EQU DFCB+32     ; текущая запись
             ;
0245                 DS 32           ; стек на 16 уровней
0265         STACK:
                     END
MACROS:

SYMBOLS:
0005   BDOS            0000    BOOT            016E	CLOSE
0010   CLOSEF          0137    COPY            0080     DBUFF
0173   DELETE          0013    DELETEF         0224     DFCB
0244   DFCBCR          0151    EOFILE          006C     FCB2
005C   FCBL            0161    FINIS           0182     MAKE
0016   MAKEF           010B    MFCB            01C1     NODIR
0187   NOFILE          020A    NORMAL          0169     OPEN
000F   OPENF           0009    PRINTF          0178     READ
0014   READF           005C    SFCB            01DA     SPACE
0265   STACK           0100    TPA             017D     WRITE
0015   WRITEF          01F3    WRPROT

Nо FATAL ERROR(S)


приложение 5
     программа распечатки файла в шестнадцатиричной форме
программа  DUMP  читает  входной  файл и  выводит  на консоль
содержимое каждой записи в шестнадцатиричной форме.
     Исходный  текст  программы находится  в  файле DUMP.MAC.  Для
получения файла DUMP.COM Необходимо выполнить следующие операции:

A>M80 =DUMP/L            <--- получение файлов DUMP.REL И DUMP.PRN

A>L80 DUMP,DUMP/N/E      <--- Получение файла DUMP.COM

     Ниже приведен листинг программы DUMP.

             ; Программа DUMP
             ; читает входной файл и выводит
             ; данные в шестнадцатиричном формате

0000                         ASEG
                             ORG 0100H
0005         BDOS    EQU 0005H       ; точка входа в BDOS
0001         CONS    EQU 1           ; чтение с консоли
0002         TYPEF   EQU 2           ; печать на консоль
0009         PRINTF  EQU 9           ; вывод в буфер консоли
000B         BRKF    EQU 11          ; функция прерывания
             ;                       ; ("истина" если нажата клавиша)
             ;
000F         OPENF   EQU 15          ; открытие файла
0014         READF   EQU 20          ; чтение файла
             ;
005C         FCB     EQU 5CH         ; блок управления файлом
0080         BUFF    EQU 80H         ; адрес буфера для ввода с диска
             ;
000D         CR      EQU 0DH         ; возврат каретки
000A         LF      EQU 0AH         ; перевод строки
             ;
             ; блок управления файлом
             ;
005C         FCBDN   EQU FCB+0       ; имя диска
005D         FCBFN   EQU FCB+1       ; имя файла
0065         FCBFT   EQU FCB+9       ; тип файла (3 символа)
0068         FCBRL   EQU FCB+12      ; номер диска
006B         FCBRC   EQU FCB+15      ; счетчик записей файла (0...128)
007C         FCBCR   EQU FCB+32      ; Номер текущей (следующей) записи
007D         FCBIN   EQU FCB+33      ; длина FCB
             ;
             ;
             ;
             ;
0100 210000          LXI H,0         ; настройка стека
0103 39              DAD SP
             ;
             ; указатель стека в HL при выходе из CCP
             ;
0104 220211          SHLD OLDSP
             ;
             ; установка SP на локальную область
             ; (восстанавливается в подпрограмме FINIS)
             ;
0107 310253          LXI SP,STKTOP
             ;
             ; чтение и печать последующих буферов
             ;
010A CD01CB          CALL SETUP      ; настройка входного файла
010D FEFF            CPI 255         ; если файл отсутствует,то 255
010F C2011B          JNZ OPENOK      ; переход, если файл открыт
             ;
             ; файл отсутствует, вывести сообщение
             ; об ошибке и возврат
             ;
0112 1101E7          LXI D,OPNMSG
0115 CD01A6          CALL ERR
0118 C3015B          JMP FINIS       ; переход к концу программы
             ;
             ; файл успешно открыт,
             ; установить индекс буфера на конец
             ;
011B 3E80    OPENOK: MVI A,80H
011D 32020F          STA IBP         ;  установить указатель буфера на
                                     ; 80H
             ;                       ; следующий адрес для печати
             ; содержится в HL
0120 210000          LXI H,0         ; начать с 0000
             ;
0123         GLOOP:
0123 E5              PUSH H          ; поместить в стек позицию в
                                     ; строке
0124 CD01AC          CALL GNB        ;
0127 E1              POP H           ; из стека позицию в строке
0128 DA015B          JC FINIS        ; если конец файла,
                                     ; устанавливается
             ;                       ; бит переноса
012B 47              MOV B,A
             ;
             ; печатать 16-е значения
             ; проверить длину строки
             ;
012C 7D              MOV A,L
012D E60F            ANI 0FH         ; проверить младшие 4 бита
012F C2014E          JNZ NONUM
             ;
             ; печатать номер строки
             ;
0132 CD017C          CALL CRLF
             ;
             ; проверить наличие клавиши прерывания
             ;
0135 CD0163          CALL BREAK
             ;
             ; если символ готов, записать в регистр LSB=1
             ;
0138 0F              RRC             ; установить бит переноса
0139 DA015B          JC FINIS        ; больше ничего не печатать
             ;
013C 7C              MOV A,H         ; печатать адрес
013D CD0199          CALL PHEX
0140 7D              MOV A,L
0141 CD0199          CALL PHEX
0144 3E20            MVI A,' '       ; два пробела после адреса
0146 CD016F          CALL PCHAR
0149 3E20            MVI A,' '
014B CD016F          CALL PCHAR
014E         NONUM:
014E 23              INX H           ; перейти к следующему номеру
                                     ; строки
014F 3E20            MVI A,' '
0151 CD016F          CALL PCHAR
0154 78              MOV A,B
0155 CD0199          CALL PHEX
0158 C30123          JMP GLOOP
             ;
015B         FINIS:
             ;
             ; конец дампа, возврат в  CCP
             ; (при переходе в 0000 - перезагрузка)
             ;
015B CD017C          CALL CRLF
015E 2A0211          LHLD OLDSP
0161 F9              SPHL
             ;
             ; указатель стека относится к стеку CCP
             ; и установлен на его начало
             ;
0162 C9              RET             ; переход в CCP
             ;
             ;
             ;   подпрограммы
             ;   ------------
             ;
             ; проверка на клавишу прерывания
             ; (в действительности так действует любая клавиша)
             ;
0163         BREAK:                  ; запомнить состояние среды
0163 E5              PUSH H
0164 D5              PUSH D
0165 C5              PUSH B
0166 0E0B            MVI C,BRKF
0168 CD0005          CALL BDOS       ; восстановить состояние среды
016B C1              POP B
016C D1              POP D
016D E1              POP H
016E C9              RET
             ;
             ; печать символа
             ;
016F         PCHAR:
016F E5              PUSH H
0170 D5              PUSH D
0171 C5              PUSH B
0172 0E02            MVI C,TYPEF
0174 5F              MOV E,A
0175 CD0005          CALL BDOS
0178 C1              POP B
0179 D1              POP D
017A E1              POP H
017B C9              RET
             ;
             ; возврат каретки и перевод строки
             ;
017C         CRLF:
017C 3E0D            MVI A,CR
017E CD016F          CALL PCHAR
0181 3E0A            MVI A,LF
0183 CD016F          CALL PCHAR
0186 C9              RET
             ;
             ; печать данных из регистра A
             ;
0187         PNIB:
0187 E60F            ANI 0FH         ; младшие 4  бита
0189 FE0A            CPI 10
018B D20193          JNC P10
             ;
             ; меньше или равно 9
             ;
018E C630            ADI '0'
0190 C30195          JMP PRN
             ;
             ; больше или равно 10
             ;
0193 C637    P10:    ADI 'A'-10
0195 CD016F  PRN:    CALL PCHAR
0198 C9              RET
             ;
0199         PHEX:                   ; печатать 16-й символ из регистра
                                     ; A
0199 F5              PUSH PSW
019A 0F              RRC
019B 0F              RRC
019C 0F              RRC
019D 0F              RRC
019E CD0187          CALL PNIB
01A1 F1              POP PSW
01A2 CD0187          CALL PNIB
01A5 C9              RET
             ;
             ; печатать сообщение об ошибке
             ; адрес лежит в DE, конец сообщения - $
             ;
01A6         ERR:
01A6 0E09            MVI C,PRINTF    ; функция печати буфера
01A8 CD0005          CALL BDOS
01AB C9              RET
             ;
             ; читать следующий байт
             ;
01AC         GNB:
01AC 3A020F          LDA IBP
01AF FE80            CPI 80H
01B1 C201BD          JNZ G0
             ;
             ; читать следующий буфер
             ;
01B4 CD01D8          CALL DISKR
01B7 B7              ORA A           ; если чтение успешное,обнулить
01B8 CA01BD          JZ G0           ; перейти к следующему байту
             ;
             ; конец данных, возврат с битом переноса,
             ; установленным, чтобы означать EOF
             ;
01BB 37              STC
01BC C9              RET
             ;
01BD         G0:                     ; прочитать байт в буфере+регистр
                                     ; A
01BD 5F              MOV E,A         ; байт индекса буфера с двойной
01BE 1600            MVI D,0         ; точностью поместить в DE
01C0 3C              INR A           ; индекс = индекс+1
01C1 32020F          STA IBP         ; назад в память
             ;
             ; значение указателя увеличено,
             ; запомнить адрес файла
             ;
01C4 210080          LXI H,BUFF
01C7 19              DAD D
             ;
             ; абсолютный адрес символа помещен в HL
             ;
01C8 7E              MOV A,M
             ;
             ; байт помещен в сумматор
             ;
01C9 B7              ORA A           ; сбросить бит переноса
01CA C9              RET
             ;
01CB         SETUP:                  ; подготовка файла
             ; открыть файл для ввода
01CB AF              XRA A           ; обнулить сумматор
01CC 32007C          STA FCBCR       ; очистить поле текущей записи
             ;
01CF 11005C          LXI D,FCB
01D2 0E0F            MVI C,OPENF
01D4 CD0005          CALL BDOS
             ; если файл открыт с ошибкой - 255 в сумматор
01D7 C9              RET
             ;
01D8         DISKR:                  ; чтение дискового файла
01D8 E5              PUSH H
01D9 D5              PUSH D
01DA C5              PUSH B
01DB 11005C          LXI D,FCB
01DE 0E14            MVI C,READF
01E0 CD0005          CALL BDOS
01E3 C1              POP B
01E4 D1              POP D
01E5 E1              POP H
01E6 C9              RET
             ;
             ; фиксированный блок с сообщениями
             ;
01E7 0D0A6E65 OPNMSG: DB CR,LF,'нет файла.   Формат: DUMP <имя файла>$'
01EB 74206661
01EF 6A6C612E
01F3 20202066
01F7 6F726D61
01FB 743A2044
01FF 554D5020
0203 3C696D71
0207 2066616A
020B 6C613E24
             ;
             ; область переменных
             ;
020F         IBP:    DS 2            ; указатель буфера ввода
0211         OLDSP:  DS 2            ; значение SP при выходе из CCP
             ;
             ; область стека
             ;
0213                 DS 64           ; область под стек - 32 уровня
0253         STKTOP:

                     END
MACROS:

SYMBOLS:
0005   BDOS            0163    BREAK           000B    BRKF
0080   BUFF            0001    CONS            000D    CR
017C   CRLF            01D8    DISKR           01A6    ERR
005C   FCB             007C    FCBCR           005C    FCBDN
005D   FCBFN           0065    FCBFT           007D    FCBIN
006B   FCBRC           0068    FCBRL           015B    FINIS
01BD   G0              0123    GLOOP           01AC    GNB
020F   IBP             000A    LF              014E    NONUM
0211   OLDSP           000F    OPENF           011B    OPENOK
01E7   OPNMSG          0193    P10             016F    PCHAR
0199   PHEX            0187    PNIB            0009    PRINTF
0195   PRN             0014    READF           01CB    SETUP
0253   STKTOP          0002    TYPEF

Nо FATAL ERROR(S)
            MOV A,B
0155 CD0199          CALL PHEX
0158 C30123          JMP GLOOP
             ;
015B         FINIS:
    